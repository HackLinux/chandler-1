=========================
Schema Definition Support
=========================

.. contents:: **Table of Contents**


------------
Introduction
------------

The ``spike.schema`` module is used to define new Spike content types and the
relationships between them.  Here's a simple example::

    >>> from spike import schema

    >>> class Person(schema.Entity):
    ...     name = schema.One(str)
    ...     age = schema.One(int)
    ...     parents = schema.Many()
    ...     children = schema.Many(inverse=parents)
    ...     def __repr__(self): return self.name

You can create instances of ``schema.Entity`` classes using keyword arguments
to set their initial attribute values, and you can also manipulate their
attributes normally after creation::

    >>> Joe = Person(name="Joe", age=39)
    >>> Joe
    Joe
    >>> Joe.age
    39
    >>> del Joe.age
    >>> Joe.age
    Traceback (most recent call last):
    ...
    AttributeError: age

    >>> Joe.age = 40

Attributes are type-checked; you can't set them to values that don't conform
to the type declared in the class::

    >>> Joe.children = ["Sam", "Nancy"]
    Traceback (most recent call last):
    ...
    TypeError: 'Sam' is not of type Person

    >>> Joe.age = 1.5
    Traceback (most recent call last):
    ...
    TypeError: 1.5 is not of type int

If an error occurs when changing an attribute, the original value is restored::

    >>> Joe.age
    40

And bidirectional relationships are automatically maintained, so for our
``Person`` class you don't have to change both the ``parents`` and ``children``
attributes, just one or the other suffices::

    >>> Bob = Person(name="Bob")
    >>> Mary = Person(name="Mary")
    >>> Joe.parents = [Bob, Mary]
    >>> list(Bob.children)
    [Joe]
    >>> list(Mary.children)
    [Joe]
    >>> del Mary.children
    >>> list(Joe.parents)
    [Bob]
    >>> Bob.children.remove(Joe)
    >>> list(Joe.parents)
    []

Sometimes, you need to be able to define a relationship without modifying one
or both of the types involved.  For example, if someone wanted to create a
"likes" relationship between ``Person`` objects, they could do it like this::

    >>> class Likes(schema.Relationship):
    ...     likedBy = schema.Many(Person)
    ...     likes   = schema.Many(Person)

Then they could use the schema dynamic API to access this data without using
attributes::

    >>> Likes.likedBy.of(Joe)
    Set([], type=Person)

    >>> Likes.likes.of(Joe).add(Bob)  # Joe likes Bob...
    >>> Likes.likes.of(Joe)
    Set([Bob], type=Person)

    >>> Likes.likedBy.of(Bob)   # Which means Bob is likedBy Joe
    Set([Joe], type=Person)

This works for all attribute definitions, not just externally-defined
relationships::

    >>> Person.age.of(Joe)
    Set([40], type=int)

For ease of programming, the ``of()`` method always returns an observable set,
even if the attribute can only have one value.  In any case, you can subscribe
to receive ``models.SetChanged`` events (see ``spike.models``) whenever a set's
membership changes::

    >>> def printIt(event): print event
    >>> Person.age.of(Joe).subscribe(printIt)

    >>> Joe.age = 41
    <Change for Set([41], type=int): removed=[40], added=[41]>
    >>> del Joe.age
    <Change for Set([], type=int): removed=[41], added=[]>
    >>> Joe.age = 40
    <Change for Set([40], type=int): removed=[], added=[40]>

    >>> Joe.age = 40    # no event, because we're not really changing anything


You can also define default values, custom initialization strategies, or
access "foreign" attributes using the ``@loader`` decorator::

    >>> class CalcDemo(schema.Entity):
    ...     @Person.age.loader
    ...     def __calcAge(self,linkset):
    ...         """implements Person.age.of(aCalcDemo)"""
    ...         print "calculating age"
    ...         linkset.add(42)
    ...
    ...     alias = schema.One(int)
    ...     @alias.loader
    ...     def __calcAlias(self,linkset):
    ...         """implements CalcDemo.alias.of(aCalcDemo)"""
    ...         print "aliasing 'alias' to Person.age"
    ...         return Person.age.of(self)

    >>> demo = CalcDemo()
    >>> list(Person.age.of(demo))
    calculating age
    [42]

    >>> demo.alias
    aliasing 'alias' to Person.age
    42

    >>> demo.alias = 19     # demo is now aliased to age, so setting sets both
    >>> list(Person.age.of(demo))
    [19]


Finally, the system issues "load events" whenever an attribute is initialized,
so that a persistence framework or "undo" facility can lazily load attribute
values or monitor attributes for changes::

    >>> schema.LoadEvent.subscribe(Bob, printIt)
    >>> Bob.age = 68
    <Load event for <Role age of <class 'Person'>> of Bob>

    >>> Bob.age = 69    # attribute is already initialized, so no load event


Entities and Values
===================

There are two fundamentally different kinds of objects you can use in Spike:
entities and values.  Entities are normally used to represent real or virtual
objects, while values are normally used to represent measurements or facts
about those objects.  So, for example, a ``Person`` class would typically be
an entity type, while a ``PersonName`` class (or a string) would be a value
type.

Entities are normally compared (and hashed) by identity, so that two entities
are only equal if they are the same entity.  After all, what would it mean
to say that two people are "equal"?  The phrase "all men are created equal"
actually refers to equal *rights*, which is to say something like
``aPerson.rights == otherPerson.rights``, which is quite different from saying
``aPerson == otherPerson``!

This identity-based comparison is Python's default behavior for user-defined
classes, unless you override special methods like ``__hash__`` and ``__eq__``.

Values, on the other hand, are normally hashed and compared by their *content*,
because more than one value object can exist with the same content.  For
example, one could create the string ``"A"`` and the string ``chr(65)``, and
although these strings may be stored at different memory locations, their
*content* is equal.  Many Python built-in types are value types, including
numbers, strings, tuples, unicode objects, and date/time values.

Here's a quick summary of the differences between entity and value types:

=======================     ===========================     ==============
                                     Entities                  Values
=======================     ===========================     ==============
Mutability                  Mutable                         Immutable
Hashing and comparisons     By identity                     By value
Relationships               Uni or Bidirectional            Unidirectional
Observable?                 Yes (Relationships changes)     No
=======================     ===========================     ==============

Values are immutable, which means they can't be changed once created.  (After
all, what would it mean to "change" the number 1?)  Because they can't be
changed, they can't directly participate in bidirectional relationships, or
be observed (listened to for changes).

Of course, not all objects fit neatly into one category or the other.  For
example, Python's list objects are compared by value, but are mutable and are
not hashable.

Spike, however, can only properly manage data that is either an entity, a
value, or an observable collection of entities or values.  You cannot simply
use Python lists or dictionaries, because these do not provide any way for
Spike's storage and UI facilities to be notified when their contents are
changed.

Spike can't absolutely enforce this rule, though. It will give you warnings or
errors when it detects something amiss, but it can't read your code or examine
arbitrary types to determine whether they're truly value types.  In part this
is because Spike wants to support built-in types like strings and numbers, and
so Spike can't require that value types inherit from a common base class.

Entity types, on the other hand, *are* required to inherit from a common base
class, ``schema.Entity``.  Typically, an application will have many entity
types, and relatively few value types, because it's somewhat less common to
need a new kind of value.


Roles and Relationships
=======================

Entities can be "related" to other entities or values.  For example, a
``Person`` object might be involved in parent-child or sibling relationships,
and an ``EmailMessage`` might have attachments.

Relationships can be unidirectional for any related object type, and
bidirectional if the related type is another entity type.  So, a person has
a unidirectional relationship with their name, because a name is a value.  But
a person can have a bidirectional relationship with another person, because
a person is another entity.

Each side of a relationship is called a "role", and each relationship has
either one or two roles.  For example, in a bidirectional parent-and-child
relationship, there is a "parent" role and a "child" role.  But in the
person-and-name relationship, there is only one role: "name".

Relationships are mutable, which is to say that the relationships between
objects can be changed.  Or, more precisely, we can say that the set of
objects playing a role in a particular relationship may change.  For example,
if a person has another child, the set of objects playing the "child" role in
relation to that person gets a new member.  Spike represents these "link sets"
using observable set objects (see ``spike.models`` and its documentation), so
that the storage and UI layers can be notified of these relationship changes.
In this way, displays and databases can be automatically updated.

In addition, Spike automatically manages the "other end" of a bidirectional
relationship for you.  If you do something like ``Sally.father = Bill``, and
there is a father-children relationship defined between ``Person`` objects,
then Spike will automatically add ``Sally`` to ``Bill.children``.  This saves
you from having to remember to update both link sets.

Spike represents roles using objects, so to create a parent-child relationship
you will literally create role objects called ``parents`` and ``children``.
These objects represent the *idea* of parents and children, not a specific
set of parents or children.  If you define these objects within the ``Person``
class, then ``Person`` instances will have attributes named ``parents`` and
``children`` that can be used to access the sets containing that person's
parents and children.

However, you are not restricted to only defining roles within an entity class.
You can also define "standalone" role and relationship objects, which you can
then use to access the link sets directly.  Role objects have an ``of()``
method that returns the corresponding link set for the given entity.  So,
``Person.parents.of(Joe)`` is just another way of accessing ``Joe.parents``,
except that it also works for roles that were not defined in the entity class.
This allows you to add new relationships to Chandler content types without
needing to change Chandler's source code.


------------
Role Objects
------------


``One`` and ``Many``
====================

``spike.schema`` offers two basic types of roles: ``schema.One`` and
``schema.Many``.  The main differences between the two are in what happens when
they are accessed as attributes, and how many items are allowed to be in the
link set for that role on a given entity.

``Many`` roles are used to implement attributes whose value is a linkset.  You
can set a ``Many`` attribute to any iterable, as long as it yields values of
a type compatible with the atribute.  However, instead of replacing the linkset
with the iterable, the linkset's *contents* are replaced, so that the attribute
is always the same linkset.  You can also delete a ``Many`` attribute (using
e.g. ``del Mary.children``), and this just empties the linkset without
replacing it.   These rules ensure that any event receivers subscribed to the
linkset will remain active.

``One`` roles are used to implement attributes whose linkset contains at most
one value.  When the linkset is empty, the attribute is "deleted", and trying
to read the attribute produces an ``AttributeError``.  When the linkset
contains an item, reading the attribute retrieves that item.

``One`` roles also support defining an initial value (either constant or
computed) to be used when the attribute is first accessed.  This can be done
by setting either the ``default`` or ``compute`` attributes of the role, where
``default`` is the value you would like to use, and ``compute`` is a callable
that takes one argument (the entity whose attribute is being computed) and
returns the value to be used::

    >>> from datetime import datetime, timedelta
    >>> now = datetime(2005, 2, 16, 13, 30)

    >>> class Appointment(schema.Entity):
    ...     start = schema.One(datetime, default=now)
    ...     end = schema.One(
    ...         datetime, compute=lambda self: self.start+timedelta(hours=1)
    ...     )
    ...     def __repr__(self):
    ...         return "%s - %s" % (self.start,self.end.strftime("%H:%M:%S"))

    >>> print Appointment()
    2005-02-16 13:30:00 - 14:30:00

If an attribute's initial value is defined using ``computed``, the calculation
is performed at the time the attribute is first accessed::

    >>> class CalcDemo(schema.Entity):
    ...     def __calcIt(self):
    ...         print "calculating"
    ...         return 42
    ...     demo = schema.One(int, compute=__calcIt)

    >>> demo = CalcDemo()
    >>> demo.demo
    calculating
    42

The calculation is always performed on the first access, even if the first
access is to immediately replace the calculated value with a new value::

    >>> demo = CalcDemo()
    >>> demo.demo = 19
    calculating
    >>> demo.demo
    19


The ``Role`` Base Type
======================

The base class for roles is ``schema.Role``.  It provides most of the
default behavior of roles, so rather than duplicate examples for each
individual role type, we'll examine the default behaviors here.

All role objects have at least the following attributes and methods:

``types`` (read-only)
    This attribute is a tuple of the types that items in the role's link sets
    are allowed to have.  You can set this initially as the first positional
    argument (`types`) of a role class' constructor, e.g.::

        >>> role = schema.Role(object)
        >>> role.types
        (<type 'object'>,)

    If not specified, there are initially no acceptable types::

        >>> role = schema.Role()
        >>> role.types
        ()

    After a role is created, you can add additional types using the
    ``addType()`` method.  In fact, the constructor just calls ``addType()``,
    so all the rules shown below for the ``addType()`` method apply.


``isReference`` (read-only)
    True if the ``types`` attribute contains one or more entity types, false
    otherwise.

        >>> role = schema.Role()
        >>> role.isReference
        False
        >>> role.addTypes(int)
        >>> role.isReference
        False

        >>> class Dummy(schema.Entity): pass
        >>> role = schema.Role(Dummy)
        >>> role.isReference
        True

``inverse``
    The role object that represents the "other side" of the relationship, or
    ``None`` if not yet set.  Setting a role's inverse automatically attempts
    to set the reverse role, so that each role's ``inverse`` attribute points
    to the other.  Thus, you do not have to set both roles' ``inverse``
    attributes in order to link them together.

    ``inverse`` can be set via keyword argument to the role class'
    constructor::

        >>> role1 = schema.Role()
        >>> print role1.inverse
        None
        >>> role2 = schema.Role(inverse=role1)
        >>> role2.inverse is role1
        True
        >>> role1.inverse is role2
        True

    Or by setting the ``inverse`` attribute after construction::

        >>> role1 = schema.Role()
        >>> role2 = schema.Role()
        >>> role2.inverse = role1
        >>> role2.inverse is role1
        True
        >>> role1.inverse is role2
        True

    Once set, it cannot be changed, unless it is to the same role::

        >>> role2.inverse = schema.Role()
        Traceback (most recent call last):
        ...
        ValueError: Role inverse cannot be changed once set

        >>> role2.inverse is role1      # no change took place
        True

    And trying to insert a new role into an existing pair also fails::

        >>> role3 = schema.Role()
        >>> print role3.inverse
        None
        >>> role3.inverse = role2
        Traceback (most recent call last):
        ...
        ValueError: Role inverse cannot be changed once set

        >>> print role3.inverse         # no change took place
        None

    Finally, note that using a pair of roles in a ``Relationship`` subclass
    automatically sets ``inverse`` for you::

        >>> class aRel(schema.Relationship):
        ...     fwd = schema.Role()
        ...     rev = schema.Role()
        >>> aRel.fwd.inverse is aRel.rev
        True
        >>> aRel.rev.inverse is aRel.fwd
        True


``addType(types)``

    Add the specified type or types to the role's ``types`` attribute::

        >>> role = schema.Role()
        >>> role.types
        ()

        >>> role.addTypes(int)
        >>> role.types
        (<type 'int'>,)

    Adding the same type more than once has no effect::

        >>> role.addTypes(int)
        >>> role.types
        (<type 'int'>,)

    You may not add more than one value type, however::

        >>> role.addTypes(str)
        Traceback (most recent call last):
        ...
        TypeError: Multiple value types not allowed in one role

        >>> role = schema.Role([str,int])
        Traceback (most recent call last):
        ...
        TypeError: Multiple value types not allowed in one role

    Nor may you mix entity and value types::

        >>> role = schema.Role([Dummy,str])
        Traceback (most recent call last):
        ...
        TypeError: Cannot mix entity and value types in one role

        >>> role = schema.Role(Dummy)
        >>> role.addTypes(str)
        Traceback (most recent call last):
        ...
        TypeError: Cannot mix entity and value types in one role

        >>> role.addTypes(schema.Entity,str)
        Traceback (most recent call last):
        ...
        TypeError: Cannot mix entity and value types in one role

        >>> role.types      # types should remain unchanged by aborted attempts
        (<class 'Dummy'>,)


``name`` (read-only)
    The name under which this role was first defined in an entity class or
    relationship, or ``None`` if the role has not been registered with a
    class yet::

        >>> role = schema.Role()
        >>> print role.name
        None
        >>> class anEntity(schema.Entity):
        ...     aRole = role
        >>> role.name
        'aRole'


``owner`` (read-only)
    The entity or relationship class in which the role was defined, or ``None``
    if the role has not been registered with a class yet::

        >>> role = schema.Role()
        >>> print role.owner
        None
        >>> class anEntity(schema.Entity):
        ...     aRole = role
        >>> role.owner
        <class 'anEntity'>

    If a role's owner is an entity class, then setting ``aRole.inverse`` will
    invoke ``aRole.inverse.addType(aRole.owner)``, so that the inverse role
    will accept instances of the first role's owning type.  This allows you
    to easily define bidirectional links without "forward references"; just
    leave off the `types` argument in both role definitions, and specify an
    `inverse` argument for the second::

        >>> class anotherEntity(schema.Entity):
        ...     otherRole = schema.Role(inverse=anEntity.aRole)
        >>> anotherEntity.otherRole.types
        (<class 'anEntity'>,)
        >>> anEntity.aRole.types
        (<class 'anotherEntity'>,)

    As you can see, this ensures that both roles can accept the owning type of
    the other role.  It also works for setting up self-recursive roles within a
    single type::

        >>> class Kind(schema.Entity):
        ...     name = schema.One(str)
        ...     subkinds = schema.Many()
        ...     superkinds = schema.Many(inverse=subkinds)
        ...     def __repr__(self):
        ...         return getattr(self,'name',object.__repr__(self))

        >>> Kind.subkinds.types
        (<class 'Kind'>,)
        >>> Kind.superkinds.types
        (<class 'Kind'>,)

``displayName`` and ``doc``
    The name and description of this role, if any.  They will be used to
    collectively form a ``__doc__`` string, so that ``help()`` is informative
    for entity types::

        >>> Kind.subkinds.doc = "Sub-kinds of this kind"
        >>> Kind.superkinds.doc = "Super-kinds of this kind"
        >>> Kind.name.doc = "This kind's name"
        >>> Kind.name.displayName = "Kind Name"

        >>> help(Kind)  # doctest: +NORMALIZE_WHITESPACE
        Help on class Kind ...
        ...
        class Kind(spike.schema.Entity)
         | ...
         |  Data and other attributes defined here:
         |
         |  name = <Role name of <class 'Kind'>>
         |      Kind Name -- One(str)
         |      
         |      This kind's name
         |  
         |  subkinds = <Role subkinds of <class 'Kind'>>
         |      Many(Kind)
         |      
         |      Sub-kinds of this kind
         |  
         |  superkinds = <Role superkinds of <class 'Kind'>>
         |      Many(Kind)
         |      
         |      Super-kinds of this kind
         |  ...


``of(ob)``
    Return the linkset for this role and `ob`.  If the role has an ``inverse``,
    `ob` must be an instance of the inverse role's types.  Otherwise, it may
    be any object with a dictionary.  If `ob` does not meet these requirements,
    ``schema.NullSet`` (an immutable empty set) is returned::

        >>> Kind.superkinds.of(schema.Entity()) is schema.NullSet
        True

        >>> Kind.name.of(27) is schema.NullSet
        True

    However, if it does meet the requirements, an observable set (see
    ``spike.models``) is returned, and is cached in ``ob.__dict__``, where it
    will be used to answer future ``of()`` requests::

        >>> aKind = Kind(name="aKind")
        >>> s = Kind.superkinds.of(aKind)
        >>> s
        Set([], type=Kind)

        >>> Kind.superkinds.of(aKind) is s      # same set returned each time
        True

        >>> Kind.superkinds in dir(aKind)   # because it's cached in __dict__
        True

    Note that it is not guaranteed that the set returned by ``of()`` is
    modifiable; for example a "derived" role type might be computed from
    other attributes of the object and would thus be unmodifiable except by
    changing the attributes from which it derived.


``@loader`` (Method decorator)
    Decorating a method as ``@someRole.loader`` designates that method as a
    loader that will be called when attempting to access ``someRole.of(ob)``
    if ``ob`` is an instance of the class the method is defined in.  The
    decorated method may modify the supplied linkset, or replace it by
    returning a new one::

        >>> class CalcDemo(schema.Entity):
        ...     @Person.age.loader
        ...     def __calcAge(self,linkset):
        ...         """implements Person.age.of(aCalcDemo)"""
        ...         print "calculating age"
        ...         linkset.add(42)
        ...
        ...     alias = schema.One(int)
        ...     @alias.loader
        ...     def __calcAlias(self,linkset):
        ...         """implements CalcDemo.alias.of(aCalcDemo)"""
        ...         print "aliasing 'alias' to Person.age"
        ...         return Person.age.of(self)

        >>> demo = CalcDemo()
        >>> list(Person.age.of(demo))
        calculating age
        [42]

        >>> demo.alias
        aliasing 'alias' to Person.age
        42

        >>> demo.alias = 19     # demo is now aliased to age, so setting sets both
        >>> list(Person.age.of(demo))
        [19]

The calculation is always performed on the first access, even if the first
access is to immediately replace the calculated value with a new value::

    >>> demo = CalcDemo()
    >>> demo.alias = 19
    aliasing 'alias' to Person.age
    calculating age
    >>> demo.alias
    19


``setLoader(cls,loadfunc)``
    Set the loader for class `cls` to `loadfunc`.  If a loader already exists
    for the class, a ``KeyError`` is raised.  When attempting to access the
    role ``of(ob)`` when ``isinstance(ob,cls)``, `loadfunc` will be called with
    the target object and a default linkset.  It can then modify the linkset
    or return a replacement linkset.


``getLoader(ob)``
    Return the most-specific loader registered with ``setLoader()`` for
    ``ob.__class__`` or a base class thereof.  If no loader was registered for
    any base class of the object's class, return None::

        >>> print CalcDemo.alias.getLoader(schema.Entity())
        None

        >>> def dummyLoader(ob,linkset): print ob, linkset
        >>> CalcDemo.alias.setLoader(schema.Entity, dummyLoader)

        >>> print CalcDemo.alias.getLoader(schema.Entity())
        <function dummyLoader at ...>

        >>> class Dummy(schema.Entity): pass
        >>> print CalcDemo.alias.getLoader(Dummy())
        <function dummyLoader at ...>

To avoid silent definition errors, ``Role`` classes will not allow setting
attributes that are not defined by their class::

    >>> r = schema.Role(foo="bar")
    Traceback (most recent call last):
    ...
    TypeError: 'foo' is not a public attribute of 'Role' objects

And, to avoid unintentional alterations, Role attributes can be set only once::

    >>> Kind.superkinds.doc = "testing"
    Traceback (most recent call last):
      ...
    TypeError: Role objects are immutable; can't change 'doc' once set



Creating Role Subclasses
========================

If you're creating a custom kind of role for a specialized application, there
are some methods you may need to override to ensure correct operation of your
subclass:

``newSet(ob)``
    Return a new (possibly empty) default linkset for `ob`.  This method is
    only called when `ob` does not have a cached linkset for the role, and it
    should simply return a new observable set of appropriate type and contents.
    The default implementation in ``Role`` just returns an observable set with
    its type restrictions set according to those of the role::

        >>> role = schema.Role(int)
        >>> role.newSet(schema.Entity())
        Set([], type=int)

    If a role has no valid types defined, this method should raise a
    ``TypeError`` to point out that the role isn't properly defined::

        >>> class anEntity(schema.Entity):
        ...     dummyRole = schema.Role()
        >>> anEntity.dummyRole.newSet(anEntity())
        Traceback (most recent call last):
        ...
        TypeError: No types defined for <Role dummyRole of <class 'anEntity'>>

    The ``newSet()`` method of ``schema.Role`` adds a subscription to its
    ``maintainInverse()`` method, which ensures that inverse linksets are
    always maintained::

        >>> anotherKind = Kind()
        >>> Kind.superkinds.of(aKind).add(anotherKind)
        >>> list(Kind.subkinds.of(anotherKind)) == [aKind]
        True

    (XXX should we do this for "unidirectional" relationships too, or let the
    repository handle it?)

    The ``newSet()`` method of ``schema.One`` also adds a subscription to
    ensure that the new set can't have more than one item in it::

        >>> class anEntity(schema.Entity):
        ...     intRole = schema.One(int)
        >>> s = anEntity.intRole.newSet(anEntity())
        >>> s
        Set([], type=int)
        >>> s.add(1)
        >>> s.add(2)
        Traceback (most recent call last):
        ...
        ValueError: <Role intRole of <class 'anEntity'>> is singular

    Note that if ``newSet`` creates any event subscriptions for the returned
    set, these should access the set only via the ``sender`` method of
    received events.  This is because load events (see `Persistence Support`_
    below) may replace the returned set with a different set instance, copying
    the event subscriptions to the new set.


Persistence Support
===================

In order to allow storage services to support delayed loading of linksets, the
``Role.of()`` method initiates a ``schema.LoadEvent`` before creating a default
linkset when the target object doesn't have a cached linkset for the role.
The event's ``sender`` is the target object, its ``role`` is the role
being requested, and its ``linkset`` is the new linkset that will be used::

    >>> foo = Kind(name="foo")
    >>> evt=schema.LoadEvent(foo, Kind.subkinds, Kind.subkinds.newSet(foo))

    >>> evt.role
    <Role subkinds of <class 'Kind'>>

    >>> evt.linkset
    Set([], type=Kind)

Receivers of this event can add or remove items from the ``linkset``, or
replace it altogether by replacing it with another observable set::

    >>> def autoload(event):
    ...     if event.role is Kind.subkinds:
    ...         event.linkset.add(Kind(name="Test"))
    ...     print event
    >>> schema.LoadEvent.subscribe(aKind,autoload)

    >>> Kind.subkinds.of(aKind)
    <Load event for <Role subkinds of <class 'Kind'>> of aKind>
    Set([Test], type=Kind)

If a receiver replaces the event's ``linkset``, the event will automatically
copy the old linkset's subscriptions to the new linkset.  The receiver,
however, is responsible for first ensuring that the new linkset's
contents and type restrictions are correct::

    >>> oldSet = evt.linkset
    >>> list(oldSet.getReceivers())
    [<function maintainInverse at ...>]

    >>> from spike import models
    >>> newSet = models.Set([], type=Kind)
    >>> list(newSet.getReceivers())
    []

    >>> evt.linkset = newSet        # changing the linkset copies receivers
    >>> list(newSet.getReceivers())
    [<function maintainInverse at ...>]


After all receivers have had a chance to affect the linkset, the role's
``of()`` method will cache and return the event's ``linkset`` attribute::

    >>> Kind.subkinds.of(aKind)     # no message, since it's cached now
    Set([Test], type=Kind)


-----------
Other Types
-----------

Standalone Relationships
========================

Sometimes, you need to be able to define a relationship without modifying one
or both of the types involved.  For example, if you want to create a new
contact-to-contact relationship with an existing ``Contact`` type whose source
code you can't modify, you can define it like this::

    >>> class Contact(schema.Entity): pass  # dummy contact class for demo

    >>> class Likes(schema.Relationship):
    ...     likedBy = schema.Many(Contact)
    ...     likes   = schema.Many(Contact)

    >>> Likes.likedBy.inverse is Likes.likes
    True
    >>> Likes.likes.inverse is Likes.likedBy
    True

You can then use ``Likes.likedBy.of(aContact)`` to find contacts who like
``aContact``, or ``Likes.likes.of(aContact)`` to find contacts who ``aContact``
likes.  This allows you to extend Chandler with new relationships between
existing types (even ones defined in different parcels), not just new types.

Note that relationship classes must be defined using exactly two roles::

    >>> class OneWay(schema.Relationship):
    ...     thisWay = schema.One()
    Traceback (most recent call last):
    ...
    ValueError: Relationship must have exactly two roles

    >>> class ThreeWay(schema.Relationship):
    ...     thisWay = schema.One()
    ...     thatWay = schema.Many()
    ...     otherWay = schema.One()
    Traceback (most recent call last):
    ...
    ValueError: Relationship must have exactly two roles

Also note that relationships cannot be subclassed; you must define a new
relationship instead::

    >>> class SortOfLikes(Likes): pass
    Traceback (most recent call last):
    ...
    TypeError: Relationships cannot be subclassed


Enumerations
============

An enumeration is a value type with a fixed set of values, defined using
the ``schema.Enumeration`` base class, and the ``schema.enum()`` descriptor::

    >>> class Importance(schema.Enumeration):
    ...     important = schema.enum("Important")
    ...     normal = schema.enum("Normal")
    ...     fyi = schema.enum("FYI")

You cannot create enumeration instances directly::

    >>> Importance("x")
    Traceback (most recent call last):
    ...
    TypeError: Enumeration instances cannot be created directly

Instead, you must access instances via the class' attributes::

    >>> Importance.normal
    Importance.normal

    >>> getattr(Importance,'normal')
    Importance.normal

Instances hash and compare equal to the string (or unicode) values assigned in
the class definition, and when converted to a string or unicode, they use that
same value::

    >>> print Importance.important
    Important

    >>> unicode(Importance.important)
    u'Important'

    >>> str(Importance.important)
    'Important'

    >>> Importance.important == "Important"
    True

    >>> hash(Importance.important) == hash("Important")
    True

Note, however, that this means each enumeration value's display name must be
unique within that enumeration type, and enumeration subclasses are not
allowed::

    >>> class BadEnum(schema.Enumeration):
    ...     foo = schema.enum("Spam")
    ...     bar = schema.enum("Spam")
    Traceback (most recent call last):
      ...
      File "<doctest schema.txt[...]>", line 1, in ?
        class BadEnum(schema.Enumeration):
      ...
    TypeError: Duplicate definitions: bar=enum(u'Spam') and foo=enum(u'Spam')

    >>> class MoreImportant(Importance):
    ...     super_urgent = schema.enum("Emergency!!!")
    Traceback (most recent call last):
    ...
      File "<doctest schema.txt[...]>", line 1, in ?
        class MoreImportant(Importance):
    ...
    TypeError: Enumerations cannot be subclassed

Finally, note that enumeration types are iterable, and they yield their
instances when iterated over, so that you can use this information
programmatically::

    >>> sorted(Importance)
    [Importance.fyi, Importance.important, Importance.normal]


---------
Internals
---------

This section describes and tests various internal aspects of the
``spike.schema`` library.  You do not need to read it unless you are working on
the internals or are just curious.


Role Activation
===============

The ``activateInClass(cls,name)`` method of role objects informs the role that
it has been used in the definition of class `cls`, under the name `name`.  This
allows a role to determine its ``name`` and ``owner`` if it does not already
know::

    >>> role = schema.Role()
    >>> class Owner(schema.Entity): pass
    >>> role.activateInClass(Owner,"foo")
    >>> role.name
    'foo'
    >>> role.owner is Owner
    True

Activating an already-activated role has no effect on its name or owner::

    >>> role.activateInClass(object,"bar")
    >>> role.name
    'foo'
    >>> role.owner is Owner
    True

And placing an instance of a ``schema.ActiveDescriptor`` subclass in either a
relationship or entity subclass automatically activates it::

    >>> class MockAttr(schema.ActiveDescriptor):
    ...     def activateInClass(self,cls,name):
    ...         print "activated %r in %r" % (name,cls)

    >>> class TestEntity(schema.Entity):
    ...     aRole = MockAttr()
    activated 'aRole' in <class 'TestEntity'>

    >>> class TestRel(schema.Relationship):
    ...     test = MockAttr()
    ...     x = schema.Role(); y = schema.Role()
    activated 'test' in <class 'TestRel'>

When a role with an ``inverse`` is activated in an entity class, the entity
class is automatically added to the types of the inverse role::

    >>> class E1(schema.Entity): pass
    >>> class E2(schema.Entity): pass
    >>> role1 = schema.Role()
    >>> role1.activateInClass(E1,"role1")
    >>> role1.types     # other end isn't activated yet, so types unknown
    ()
    >>> role2 = schema.Role()
    >>> role2.inverse = role1
    >>> role2.types     # this gets set because inverse is set
    (<class 'E1'>,)
    >>> role2.activateInClass(E2,"role2")
    >>> role1.types
    (<class 'E2'>,)


Loader Decoration
=================

The ``loader`` decorator works by returning an ``ActiveDescriptor`` subclass
instance that calls back to ``setLoader()`` when activated::

    >>> def dummyLoader(ob,linkset): print ob, linkset
    >>> loader = CalcDemo.alias.loader(dummyLoader)

    >>> loader      # doctest: +NORMALIZE_WHITESPACE
    <Loader wrapping <function dummyLoader at ...>
    for <Role alias of <class 'CalcDemo'>>>

    >>> loader.activateInClass(object,'dummy')
    >>> CalcDemo.alias.getLoader(object())
    <function dummyLoader at ...>


Role Pickling
=============

Roles should be able to be pickled and unpickled as "global objects", meaning
that they are singletons imported from a module, rather than objects whose
state is saved in the pickle.  This is accomplished via the ``__reduce_ex__``
method::

    >>> Kind.subkinds.__reduce_ex__()
    (<function load_role at ...>, (<class 'Kind'>, 'subkinds'))

And the ``load_role`` function takes care of restoring pickled roles::

    >>> schema.load_role(Kind, 'subkinds') is Kind.subkinds
    True
    >>> schema.load_role.__safe_for_unpickling__
    True

    >>> schema.load_role(Kind, 'xyz')
    Traceback (most recent call last):
    ...
    AttributeError: type object 'Kind' has no attribute 'xyz'

But it doesn't allow non-roles to be unpickled::

    >>> schema.load_role(Kind, '__class__')
    Traceback (most recent call last):
    ...
    AssertionError: Can't unpickle non-roles this way

Of course, it's possible that a role might not have been used in a class, in
which case it doesn't know its owner or name, and can't be reduced this way.
So, arbitrary roles can still be pickled, at least in principle.  Roles just
delegate to Python's built-in ``__reduce_ex__`` if the role has not been
activated in a class, so any normal pickling restrictions will apply::

    >>> schema.Role().__reduce_ex__()   # doctest: +NORMALIZE_WHITESPACE
    (<...>, (<class '...schema.Role'>, <type 'object'>, None),
    {'__doc__': 'Role(())', 'types': (), '_loadMap': {}})


Type Flattening
===============

The ``iterTypes()`` routine takes a type or (possibly nested) sequence of types
as input, and yields the type objects that were input::

    >>> list(schema.iterTypes(object))
    [<type 'object'>]
    >>> list(schema.iterTypes((int,str)))
    [<type 'int'>, <type 'str'>]
    >>> list(schema.iterTypes((object,(int,str))))
    [<type 'object'>, <type 'int'>, <type 'str'>]

If an object is found that is neither a type nor a sequence, an error occurs::

    >>> list(schema.iterTypes(123))
    Traceback (most recent call last):
    ...
    TypeError: 123 is not a type or sequence of types

Strings require special handling to avoid infinite recursion, so let's test
them too::

    >>> list(schema.iterTypes("xyz"))
    Traceback (most recent call last):
    ...
    TypeError: 'x' is not a type or sequence of types

But the special handling should be applicable to any stringlike object, so
we'll try it with unicode, too::

    >>> list(schema.iterTypes(u"xyz"))
    Traceback (most recent call last):
    ...
    TypeError: u'x' is not a type or sequence of types


-----
To Do
-----

Roles

* Role knows its requiredness, and other metadata (policies?)


Entity Classes

* Entity.__setattr__ only allows setting class-defined, non-method attributes


Misc.

* Support derived roles, mappings

* Unique keys via ``schema.Key(*roles)``

* All schema objects know their fully-qualified import name (for UUID lookups)

* Should we have a general hook for attribute metadata, like in peak.binding?
  Since we have to scan and activate descriptors so they know their name, it
  seems reasonable to allow other metadata here.  It would also prevent an
  explosion of keyword options to descriptors and roles as Chandler's metadata
  needs evolve, while allowing third parties to define and use their own kinds
  of structural metadata.

