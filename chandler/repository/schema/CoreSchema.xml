<?xml version="1.0"?>

<DomainSchema itemName="core:CoreSchema" root="Core" bootstrap="True"
  xmlns="http://osafoundation.org/2003/08/CoreSchema"
  xmlns:core="http://osafoundation.org/2003/08/CoreSchema"
  xml:base="http://osafoundation.org/2003/08/CoreSchema">

<!-- the 'itemPathMapping' elements may be temporary -->
<!-- they might get replaced once we figure out parcel loading -->
<!-- right now, they're very handy for the xslt transform to our 'pack & item xml' formats -->
  <itemPathMapping prefix="core" path="//Schema/Model/Proposed/"/>

  <displayName>Core</displayName>
  <version>0</version>
  <dependsOn itemref="core:CoreSchema"/>
  <description>
    Chandler stores Items.
    example: Chandler stores my calendar event "Lunch with Tug" 
     
    Each Item can be an instance of some Kind.
    example: "Lunch with Tug" is an instance of an "Calendar Event" 
     
    Each Kind has a set of implied Attributes.
    example: A "Calendar Event" has a "start time", an "end time", a "headline", etc.
     
    Each Item instance has it's own list of Attribute Values.
    example: "Lunch with Tug" has a "start time", an "end time", a "headline", etc.
     
    An Item can have more Attributes than are in the set of implied Attributes for that Kind.
    example: "Lunch with Tug" has an "imaginary" attribute, even though "Calendar Event" does not have an "imaginary" attribute.
     
    Each attribute of an Item can have a Value.
    example: The "start time" of "Lunch with Tug" is "1:00pm".
     
    A value can be a literal, or a reference to another Item.
    example: The "start time" of "Lunch with Tug" is "1:00pm, 15 Mar 1992".
    example: The "owner" of "Lunch with Tug" is the user Tug, who created the Calendar Event.
     
    A Literal is an instance of some Type.
    example: "1:00pm, 15 Mar 1992" is a "datetime" 
     
    An Attribute on one Kind can have a inverse Attribute on another Kind
    example: The "reminder" attribute of "Calendar Event" is the inverse of the "event" attribute of "Reminder", so that each event knows whether it has a reminder, and each reminder knows which event to remind the user of.
  </description>

<!-- Global Attributes -->
  <Attribute itemName="core:anyName">
    <displayName>displayName</displayName>
    <description>Any sort of human-readable name for an item.</description>
    <cardinality>single</cardinality>
    <type itemref="core:AnyString"/>
  </Attribute>

  <Attribute itemName="core:displayName" bootstrap="False">
    <displayName>name</displayName>
    <description>A human-readable display name for an item.</description>
    <superAttribute itemref="core:anyName"/>
  </Attribute>

  <Attribute itemName="core:abbreviation">
    <displayName>abbreviation</displayName>
    <description>A human-readable abbreviation for a name.</description>
    <superAttribute itemref="core:anyName"/>
  </Attribute>

<!-- this is an *intrinsic attribute*, not a *Chandler attribute*
  <Attribute itemName="core:itemName">
    <displayName>identifier name</displayName>
    <description>A name for use in computer programs. No spaces or special characters. Similar to (dublin core: creator).</description>
    <type itemref="core:Symbol"/>
    <superAttribute itemref="core:displayName"/>
    <hidden/>
  </Attribute>
-->

  <Attribute itemName="core:annotation">
    <displayName>annotation</displayName>
    <description>Any sort of description or annotation for an item.</description>
    <cardinality>set</cardinality>
    <type itemref="core:AnyString"/>
  </Attribute>

  <Attribute itemName="core:description" boostrap="False">
    <displayName>description</displayName>
    <description>Any sort of comment or description to explain more about an item.</description>
    <cardinality>single</cardinality>
    <type itemref="core:AnyString"/>
    <superAttribute itemref="core:annotation"/>
  </Attribute>

  <Attribute itemName="core:examples">
    <displayName>example</displayName>
    <description>An example of this item.</description>
    <superAttribute itemref="core:annotation"/>
  </Attribute>

  <Attribute itemName="core:issues">
    <displayName>issue</displayName>
    <description>Any open issue with this item.</description>
    <superAttribute itemref="core:annotation"/>
  </Attribute>

  <Attribute itemName="core:equivalentTo">
    <displayName>equivalent to</displayName>
    <description>This item is conceptually equivalent to these others.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Item"/>
    <inverseAttribute itemref="core:equivalentTo"/>
    <referencePolicy>equivalent</referencePolicy>
  </Attribute>

  <Attribute itemName="core:hidden">
    <displayName>hidden</displayName>
    <description>Is this a 'hidden' system Type used for house-keeping, or is this a domain Type that an end-user would want to see?</description>
    <cardinality>single</cardinality>
    <type itemref="core:Boolean"/>
    <hidden/>
    <defaultValue>false</defaultValue>
  </Attribute>

  <Attribute itemName="core:type" bootstrap="True">
    <displayName>type</displayName>
    <description>What sorts of values can this field or attribute have?</description>
    <cardinality>single</cardinality>
    <type itemref="core:Taxon"/>
    <inverseAttribute itemref="core:typeFor"/>
    <defaultValue>core:Anything</defaultValue>
  </Attribute>

  <Attribute itemName="core:typeFor">
    <displayName>used as type in</displayName>
    <description>What fields and attributes use this taxon as their type?</description>
    <cardinality>set</cardinality>
    <inverseAttribute itemref="core:type"/>
  </Attribute>

<!-- Item -->
  <Attribute itemName="core:uuid">
    <displayName>uuid</displayName>
    <description>The unique id of this item. Similar to (dublin core: creator).</description>
    <cardinality>single</cardinality>
    <required/>
    <type itemref="core:UUID"/>
    <hidden/>
  </Attribute>

  <Attribute itemName="core:instanceOf">
    <displayName>instance of</displayName>
    <description>The Kind (or Kinds) that this item is an instance of.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Kind"/>
    <inverseAttribute itemref="core:instanceItems"/>
  </Attribute>

  <Attribute itemName="core:instanceItems" bootstrap="True">
    <displayName>items</displayName>
    <description>The items that are instances of this Kind.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Item"/>
    <inverseAttribute itemref="core:instanceOf"/>
  </Attribute>

  <Attribute itemName="core:kind" bootstrap="True">
    <displayName>instance of</displayName>
    <description>The Kind that this item is an instance of. An item can be an instance of only one main Kind, although it can have additional kinds that it is also considered to be an instance of.</description>
    <issues>Brian suggests changing the name to "instanceOf" or "instanceOfKind"</issues>
    <cardinality>single</cardinality>
    <superAttribute itemref="core:instanceOf"/>
    <defaultValue>common:GenericItem</defaultValue>
    <inverseAttribute itemref="core:items"/>
  </Attribute>

  <Attribute itemName="core:items" bootstrap="True">
    <displayName>items</displayName>
    <description>The items that are instances of this Kind.</description>
    <issues>Brian suggests changing the name to "instanceItems"</issues>
    <cardinality>set</cardinality>
    <superAttribute itemref="core:instanceItems"/>
    <type itemref="core:Item"/>
    <inverseAttribute itemref="core:kind"/>
  </Attribute>

  <Attribute itemName="core:secondaryKinds">
    <displayName>instance of secondary kinds</displayName>
    <description>Other Kinds that this item is also an instance of. An item can be an instance of more than one Kind. For example, a particular 'Email Message' could also be a 'Task'.</description>
    <cardinality>set</cardinality>
    <superAttribute itemref="core:instanceOf"/>
    <inverseAttribute itemref="core:secondaryItems"/>
  </Attribute>

  <Attribute itemName="core:secondaryItems">
    <displayName>seondary items</displayName>
    <description>The items that have this Kind as a secondary Kind.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Item"/>
    <superAttribute itemref="core:instanceItems"/>
    <inverseAttribute itemref="core:secondaryKinds"/>
  </Attribute>

  <Attribute itemName="core:createdBy">
    <displayName>created by</displayName>
    <description>Who made this item? Similar to (dublin core: creator).</description>
    <cardinality>single</cardinality>
    <required/>
    <type itemref="core:Operator"/>
    <hidden/>
    <inverseAttribute itemref="core:itemsCreated"/>
  </Attribute>

  <Attribute itemName="core:creationTime">
    <displayName>creation time</displayName>
    <description>When was this item created? Similar to (dublin core: created).</description>
    <cardinality>single</cardinality>
    <required/>
    <type itemref="core:DateTime"/>
    <hidden/>
    <defaultValue>now</defaultValue>
  </Attribute>

  <Attribute itemName="core:lastModifiedTime">
    <displayName>last modified time</displayName>
    <description>When was this item last modified?</description>
    <cardinality>single</cardinality>
    <required/>
    <type itemref="core:DateTime"/>
    <hidden/>
    <defaultValue>now</defaultValue>
  </Attribute>

  <Attribute itemName="core:deleted">
    <displayName>deleted</displayName>
    <description>Is this item now logically deleted?</description>
    <cardinality>single</cardinality>
    <required/>
    <type itemref="core:Boolean"/>
    <hidden/>
    <defaultValue>false</defaultValue>
  </Attribute>

<!-- this is an *intrinsic attribute*, not a *Chandler attribute*
  <Attribute itemName="core:itemParent">
    <displayName>item parent</displayName>
    <description>The parent item in the repository containment hierarchy. If the parent value is null, then this is a root item.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Item"/>
    <hidden/>
    <inverseAttribute itemref="core:itemChild"/>
    <referencePolicy>parent</referencePolicy>
  </Attribute>
-->

<!-- this is an *intrinsic attribute*, not a *Chandler attribute*
  <Attribute itemName="core:itemChild">
    <displayName>item children</displayName>
    <description>The children items in the repository containment hierarchy.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Item"/>
    <hidden/>
    <inverseAttribute itemref="core:itemParent"/>
    <referencePolicy>children</referencePolicy>
  </Attribute>
-->

<!-- this is an *intrinsic attribute*, not a *Chandler attribute*
  <Attribute itemName="core:itemPath">
    <displayName>item path</displayName>
    <description>Path within the Chandler repository.</description>
    <derivationNotes>Derived from 'item parent' and 'item name'</derivationNotes>
    <cardinality>single</cardinality>
    <type itemref="core:ItemPath"/>
    <hidden/>
  </Attribute>
-->

  <Attribute itemName="core:proxyFor">
    <displayName>proxy for</displayName>
    <description>If this item is a copy of some record from another PIM, what's the address of the foreign record?</description>
    <cardinality>single</cardinality>
    <type itemref="core:ForeignItem"/>
    <hidden/>
    <inverseAttribute itemref="core:localCopy"/>
    <referencePolicy>owns</referencePolicy>
  </Attribute>

  <Attribute itemName="core:note">
    <displayName>note</displayName>
    <description>Any notes or annotations that people have made about this item.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Note"/>
    <inverseAttribute itemref="core:noteAppliesTo"/>
    <superAttribute itemref="core:annotation"/>
  </Attribute>

  <Attribute itemName="core:adHocAttributeList">
    <displayName>ad hoc attribute list</displayName>
    <description>What attributes have been added to this individual item?</description>
    <cardinality>set</cardinality>
    <type itemref="core:Attribute"/>
    <hidden/>
    <inverseAttribute itemref="core:usedAsAdHocAttributeInItems"/>
  </Attribute>

  <Attribute itemName="core:sameItemAs">
    <displayName>same item as</displayName>
    <description>If two items conceptually represent the same thing, we can use this attribute to make a note of that.  For example, in my address book I might accidentally create two different 'Contacts' for Amy Merkle.  I don't want to delete either of them, because other Items reference them, but I do want to Chandler to understand they're really should be the same Item.  See also the RDF/OWL notion of 'owl:sameIndividualAs'.</description>
    <inverseAttribute itemref="core:sameItemAs"/>
    <superAttribute itemref="core:equivalent"/>
  </Attribute>

  <Attribute itemName="core:suppliedIn">
    <displayName>supplied in</displayName>
    <description>The Domain Schema where this item comes from.</description>
    <cardinality>single</cardinality>
    <type itemref="core:DomainSchema"/>
    <hidden/>
    <inverseAttribute itemref="core:itemsSupplied"/>
  </Attribute>

  <Kind itemName="core:Item" bootstrap="True">
    <displayName>Item</displayName>
    <displayAttribute itemref="core:displayName"/>
    <attributes itemref="core:itemName"/>
    <attributes itemref="core:uuid"/>
    <attributes itemref="core:instanceOfPrimaryKind"/>
    <attributes itemref="core:instanceOfAdditionalKind"/>
    <attributes itemref="core:createdBy"/>
    <attributes itemref="core:creationTime"/>
    <attributes itemref="core:lastModifiedTime"/>
    <attributes itemref="core:deleted"/>
    <attributes itemref="core:proxyFor"/>
    <attributes itemref="core:note"/>
    <attributes itemref="core:adHocAttributeList"/>
    <attributes itemref="core:sameItemAs"/>
    <attributes itemref="core:suppliedIn"/>
  </Kind>

<!-- Domain Schema -->
  <Attribute itemName="core:dependsOn">
    <displayName>dependent on</displayName>
    <description>The other Domain Schemas that this one builds on top of.</description>
    <cardinality>set</cardinality>
    <type itemref="core:DomainSchema"/>
    <inverseAttribute itemref="core:isUsedBy"/>
    <referencePolicy>parent</referencePolicy>
  </Attribute>

  <Attribute itemName="core:isUsedBy">
    <displayName>is used by</displayName>
    <description>The other Domain Schemas that are built on top of this one.</description>
    <cardinality>set</cardinality>
    <type itemref="core:DomainSchema"/>
    <inverseAttribute itemref="core:dependsOn"/>
    <referencePolicy>children</referencePolicy>
  </Attribute>

  <Attribute itemName="core:version">
    <displayName>version</displayName>
    <description>Version info for this Domain Schema.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Version"/>
    <inverseAttribute itemref="core:currentItem"/>
    <superAttribute itemref="core:annotation"/>
  </Attribute>

  <Attribute itemName="core:schemaDefinitions">
    <displayName>definitions</displayName>
    <description>All the stuff defined by this schema: Types, Kinds, Attribute Definitions, Enums, etc.</description>
    <cardinality>set</cardinality>
    <inverseAttribute itemref="core:definedInDomainSchema"/>
    <referencePolicy>owns</referencePolicy>
  </Attribute>

  <Attribute itemName="core:definedInDomainSchema">
    <displayName>defined in</displayName>
    <description>The Domain Schema where this item is defined.</description>
    <cardinality>single</cardinality>
    <type itemref="core:DomainSchema"/>
    <inverseAttribute itemref="core:schemaDefinitions"/>
    <referencePolicy>ownedBy</referencePolicy>
  </Attribute>

  <Attribute itemName="core:definedTypes">
    <displayName>defined Types</displayName>
    <description>All the Types defined by this schema</description>
    <type itemref="core:Type"/>
    <inverseAttribute itemref="core:typeDefinedInDomainSchema"/>
    <superAttribute itemref="core:schemaDefinitions"/>
  </Attribute>

  <Attribute itemName="core:definedKinds">
    <displayName>defined Kinds</displayName>
    <description>All the Kinds defined by this schema</description>
    <type itemref="core:Kind"/>
    <inverseAttribute itemref="core:kindDefinedInDomainSchema"/>
    <superAttribute itemref="core:schemaDefinitions"/>
  </Attribute>

  <Attribute itemName="core:definedAttributes">
    <displayName>defined Attribute Definitions</displayName>
    <description>All the Attribute Definitions defined by this schema</description>
    <type itemref="core:Attribute"/>
    <inverseAttribute itemref="core:attributeDefinedInDomainSchema"/>
    <superAttribute itemref="core:schemaDefinitions"/>
  </Attribute>

  <Attribute itemName="core:definedAliases">
    <displayName>defined Aliases</displayName>
    <description>All the Aliases defined by this schema</description>
    <type itemref="core:Alias"/>
    <inverseAttribute itemref="core:aliasDefinedInDomainSchema"/>
    <superAttribute itemref="core:schemaDefinitions"/>
  </Attribute>

  <Attribute itemName="core:itemsSupplied">
    <displayName>items supplied</displayName>
    <description>All the items included with the domain schema -- typically enum instances, but they could be anything.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Item"/>
    <inverseAttribute itemref="core:suppliedIn"/>
  </Attribute>

  <Kind itemName="core:DomainSchema">
    <displayName>Domain Schema</displayName>
    <displayAttribute itemref="core:displayName"/>
    <issues>We should arrange for each Domain Schema to have a namespace.  We might do that just by having an attribute on Domain Schema, or we might want to do something fancier using the Semantic Mapping feature.</issues>
    <superKinds itemref="core:Item"/>
    <attributes itemref="core:displayName"/>
    <attributes itemref="core:description"/>
    <attributes itemref="core:examples"/>
    <attributes itemref="core:issues"/>
    <attributes itemref="core:dependsOn"/>
    <attributes itemref="core:isUsedBy"/>
    <attributes itemref="core:version"/>
    <attributes itemref="core:definedTypes"/>
    <attributes itemref="core:definedKinds"/>
    <attributes itemref="core:definedAttributes"/>
    <attributes itemref="core:definedAliases"/>
    <attributes itemref="core:itemsSupplied"/>
  </Kind>

<!-- Taxon -->
  <Attribute itemName="core:usedInAlias">
    <displayName>used in alias</displayName>
    <description>What are all the various Aliases that include this taxon?</description>
    <cardinality>set</cardinality>
    <type itemref="core:Alias"/>
    <inverseAttribute itemref="core:aliasFor"/>
  </Attribute>

  <Kind itemName="core:Taxon" bootstrap="True">
    <displayName>Taxon</displayName>
    <description>
      Taxon can be a Kind, or a Type, or a Kind-of-Compound-Attribute. Taxon is an abstract superkind for these three other kinds.
    </description>
    <superKinds itemref="core:Item"/>
    <displayAttribute itemref="core:displayName"/>
    <abstract/>
    <attributes itemref="core:displayName"/>
    <attributes itemref="core:description"/>
    <attributes itemref="core:examples"/>
    <attributes itemref="core:issues"/>
    <attributes itemref="core:hidden"/>
    <attributes itemref="core:typeFor"/>
    <attributes itemref="core:usedInAlias"/>
  </Kind>

<!-- Type -->
  <Attribute itemName="core:typeDefinedInDomainSchema">
    <displayName>defined in</displayName>
    <description>...add description here...</description>
    <superAttribute itemref="core:definedInDomainSchema"/>
    <inverseAttribute itemref="core:definedTypes"/>
  </Attribute>

  <Attribute itemName="core:formats">
    <displayName>formats</displayName>
    <description>What display formats are available for this type?</description>
    <cardinality>set</cardinality>
    <type itemref="core:AttributeFormat"/>
    <inverseAttribute itemref="core:appliesToType"/>
  </Attribute>

  <Kind itemName="core:Type" bootstrap="True">
    <displayName>Type</displayName>
    <examples>'integer'</examples>
    <examples>'boolean'</examples>
    <examples>'string'</examples>
    <description>
      Items have attributes. Each attribute can have some associated type, and the attribute values for that attribute are restricted to being values of that type. An attribute's values can be completely unrestricted, or they can be restricted to some specific Kind, or some specific Type.
    </description>
    <issues>What is the list of supported types?</issues>
    <issues>Can a new Parcel create a new Type?</issues>
    <issues>What's actually involved in supporting a new Type? Beyond simply creating a new instance in the repository, what Chandler code has to be changed?</issues>
    <issues>What's the relationship between (a) a Type and (b) the formatting options for that Type? Should 'percentage' really be its own Type, or should it just be a way of formatting 'float'?</issues>
    <superKinds itemref="core:Taxon"/>
    <attributes itemref="core:typeDefinedInDomainSchema"/>
    <attributes itemref="core:formats"/>
  </Kind>

<!-- Compound-Type -->
  <Attribute itemName="core:fields" bootstrap="True">
    <displayName>fields</displayName>
    <description>The fields in a compound type.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Field"/>
    <inverseAttribute itemref="core:owningType"/>
    <referencePolicy>owns</referencePolicy>
  </Attribute>

  <Kind itemName="core:CompoundType">
    <displayName>Compound-Type</displayName>
    <examples>'date' = 'year', 'month', 'day'</examples>
    <examples>'time' = 'hour', 'minute', 'second'</examples>
    <examples>'datetime' = 'date', 'time', 'timezone'</examples>
    <examples>'fraction' = 'numerator', 'denominator'</examples>
    <examples>'person name' = 'first name', 'middle name', 'last name', 'title', 'suffix'</examples>
    <examples>'quantity' = 'number', 'unit'</examples>
    <description>
      A Kind describes all the attributes that Items of that kind might typically have.  Similarly, a Compound-Type describes all the fields that compound literal might typically have.  Compound literals are similar to items, in that they both contain attributes.  But compound literals don't have UUIDs, so a compound literal can never be refered to except as a part of an item.  Compound literals are 'wholly owned' by the items that use them.
      For example, you might have a Person item that represents Abraham Lincoln. The item will have attributes, like 'date of birth', 'date of death', 'name', and 'nickname'. And the item has a UUID, and can be refered to by other items.  The 'nickname' attribute just holds a simple string literal, but the 'name' attribute holds a compound literal of the type 'person name', which has fields for 'first name', 'middle name', 'last name', etc.
    </description>
    <superKinds itemref="core:Type"/>
    <attributes itemref="core:fields"/>
  </Kind>
  
<!-- Field -->
  <Attribute itemName="core:owningType">
    <displayName>owning type</displayName>
    <description>The compound type that this field is a part of.</description>
    <cardinality>single</cardinality>
    <type itemref="core:CompoundType"/>
    <inverseAttribute itemref="core:fields"/>
    <referencePolicy>ownedBy</referencePolicy>
  </Attribute>

  <Kind itemName="core:Field">
    <displayName>Field</displayName>
    <superKinds itemref="core:Item"/>
    <displayAttribute itemref="core:displayName"/>
    <attributes itemref="core:displayName"/>
    <attributes itemref="core:description"/>
    <attributes itemref="core:examples"/>
    <attributes itemref="core:issues"/>
    <attributes itemref="core:owningType"/>
    <attributes itemref="core:type"/>
  </Kind>

<!-- Kind -->
  <Attribute itemName="core:abstract">
    <displayName>abstract</displayName>
    <description>TRUE if this is an abstract superkind and cannot be instantiated.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Boolean"/>
    <defaultValue>false</defaultValue>
  </Attribute>

  <Attribute itemName="core:attributes" bootstrap="True">
    <displayName>implied attributes</displayName>
    <description>A set of attributes typically found on items of this Kind.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Attribute"/>
    <inverseAttribute itemref="core:kinds"/>
  </Attribute>

  <Attribute itemName="core:displayAttribute" bootstrap="False">
    <displayName>display attribute</displayName>
    <description>For items of this kind, what attribute should we look in to find a human readable name for this item?  For example, in an Email Message item we might use the 'subject' attribute, and in a Contact item we might use the 'person name' attribute.</description>
    <cardinality>single</cardinality>
    <type itemref="core:AttributeOrAttributeChain"/>
    <inverseAttribute itemref="core:usedAsDisplayAttribute"/>
  </Attribute>

  <Attribute itemName="core:equivalentKinds">
    <displayName>equivalent kinds</displayName>
    <description>Similar to the RDF/OWL property 'owl:equivalentClass'.</description>
    <type itemref="core:Kind"/>
    <inverseAttribute itemref="core:equivalentKinds"/>
    <superAttribute itemref="core:equivalent"/>
  </Attribute>

  <Attribute itemName="core:kindDefinedInDomainSchema">
    <displayName>defined in</displayName>
    <description>...add description here...</description>
    <superAttribute itemref="core:definedInDomainSchema"/>
    <inverseAttribute itemref="core:definedKinds"/>
  </Attribute>

  <Attribute itemName="core:superKinds" bootstrap="True">
    <displayName>super kind</displayName>
    <description>The superkinds for this kind.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Kind"/>
    <inverseAttribute itemref="core:subKinds"/>
    <referencePolicy>parent</referencePolicy>
    <defaultValue>core:Item</defaultValue>
  </Attribute>

  <Attribute itemName="core:subKinds" bootstrap="True">
    <displayName>sub kinds</displayName>
    <description>The subkinds of this kind.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Kind"/>
    <inverseAttribute itemref="core:superKinds"/>
    <referencePolicy>children</referencePolicy>
  </Attribute>

  <Kind itemName="core:Kind" bootstrap="True">
    <displayName>Kind</displayName>
    <examples>Calendar Event</examples>
    <examples>Contact</examples>
    <examples>Sailing Ship</examples>
    <examples>Homework Assignment</examples>
    <description>
      A Kind represents a 'type', or 'class', or 'category' of items.
      A Kind can represent: new user-defined Kind ('Book', 'Sailing Ship', 'Course', 'Homework Assignment', 'Grade', etc.).
      A Kind can represent: a Kind from a standard Parcel ('Calendar Event', 'Task', 'Contact', etc.)
      A Kind can represent: a basic Kind of system Item ('Kind', 'Item', 'Change')
    </description>
    <superKinds itemref="core:Taxon"/>
    <attributes itemref="core:items"/>
    <attributes itemref="core:abstract"/>
    <attributes itemref="core:attributes"/>
    <attributes itemref="core:displayAttribute"/>
    <attributes itemref="core:equivalentKinds"/>
    <attributes itemref="core:kindDefinedInDomainSchema"/>
    <attributes itemref="core:superKinds"/>
    <attributes itemref="core:subKinds"/>
  </Kind>

<!-- Alias -->
  <Attribute itemName="core:aliasFor">
    <displayName>alias for</displayName>
    <description>What are all the various Types or Kinds that this is an alias for?</description>
    <issue>In the schema of schemas, this is called "types"</issue>
    <cardinality>set</cardinality>
    <required/>
    <type itemref="core:Taxon"/>
    <inverseAttribute itemref="core:usedInAlias"/>
  </Attribute>

  <Attribute itemName="core:aliasDefinedInDomainSchema">
    <displayName>defined in</displayName>
    <description>...add description here...</description>
    <superAttribute itemref="core:definedInDomainSchema"/>
    <inverseAttribute itemref="core:definedAliases"/>
  </Attribute>

  <Kind itemName="core:Alias">
    <displayName>Taxon Alias</displayName>
    <examples>'String' = 'ASCII String' | 'Unicode String' | 'Polyglot String'</examples>
    <examples>'Datetime' = 'Rigid Datetime' | 'Flexible Datetime'</examples>
    <examples>'Anything' = 'Item' | 'Literal'</examples>
    <description>
      Let's say 'String' is a type that's an alias for either 'Unicode String' or 'Polyglot String'. Then, if an Attribute Definition is supposed to be of type 'String', that means the attribute value can be a Unicode String or a Polyglot String
    </description>
    <superKinds itemref="core:Taxon"/>
    <attributes itemref="core:aliasFor"/>
    <attributes itemref="core:aliasDefinedInDomainSchema"/>
  </Kind>

<!-- Attribute Or Attribute Chain -->
  <Alias itemName="core:AttributeOrAttributeChain">
    <aliasFor itemref="core:Attribute"/>
    <aliasFor itemref="core:AttributeChain"/>
  </Alias>

<!-- Attribute -->
  <Attribute itemName="core:superAttribute" bootstrap="True">
    <displayName>super attribute</displayName>
    <description>What attribute is this a sub-attribute of?</description>
    <cardinality>single</cardinality>
    <type itemref="core:Attribute"/>
    <inverseAttribute itemref="core:subAttributes"/>
    <referencePolicy>parent</referencePolicy>
  </Attribute>

  <Attribute itemName="core:subAttributes" bootstrap="True">
    <displayName>sub attributes</displayName>
    <description>What attributes have this one as their super attribute?</description>
    <cardinality>set</cardinality>
    <type itemref="core:Attribute"/>
    <inverseAttribute itemref="core:superAttribute"/>
    <referencePolicy>children</referencePolicy>
  </Attribute>

  <Attribute itemName="core:cardinality" bootstrap="True">
    <displayName>cardinality</displayName>
    <description>How many values can this attribute have?</description>
    <cardinality>single</cardinality>
    <type itemref="core:CardinalityEnum"/>
    <defaultValue>core:single</defaultValue>
  </Attribute>

  <Attribute itemName="core:defaultValue" bootstrap="True">
    <displayName>default value</displayName>
    <description>What default value is 'copied' into new instances?</description>
    <cardinality>single</cardinality>
    <type itemref="core:Anything"/>
  </Attribute>

  <Attribute itemName="core:defaultFormat">
    <displayName>default format</displayName>
    <description>How should this attribute be displayed in a table?</description>
    <cardinality>single</cardinality>
    <type itemref="core:AttributeFormat"/>
    <inverseAttribute itemref="core:usedAsDefaultFormat"/>
  </Attribute>

  <Attribute itemName="core:restrictions">
    <displayName>restrictions</displayName>
    <description>What restrictions are there on the values we expect to have for attribute?</description>
    <cardinality>set</cardinality>
    <type itemref="core:AttributeRestriction"/>
    <inverseAttribute itemref="core:appliesToAttribute"/>
    <referencePolicy>owns</referencePolicy>
  </Attribute>

  <Attribute itemName="core:equivalentAttributes">
    <displayName>equivalent attributes</displayName>
    <description>Similar to the RDF/OWL property 'owl:equivalentProperty'.</description>
    <type itemref="core:Attribute"/>
    <inverseAttribute itemref="core:equivalentAttributes"/>
    <superAttribute itemref="core:equivalent"/>
  </Attribute>

  <Attribute itemName="core:required" bootstrap="True">
    <displayName>required</displayName>
    <description>TRUE if this attribute is not allowed to have a NULL value.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Boolean"/>
    <defaultValue>false</defaultValue>
  </Attribute>

  <Attribute itemName="core:derivationNotes">
    <displayName>derivation notes</displayName>
    <description>How should Chandler automatically calculate the value of this attribute?</description>
    <cardinality>single</cardinality>
    <type itemref="core:String"/>
  </Attribute>
  
  <Attribute itemName="core:inverseAttribute">
    <displayName>inverse attribute</displayName>
    <description>On the item that this attribute points to, what attribute points to this item?  Similar to the RDF/OWL property 'owl:inverseOf'.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Attribute"/>
    <inverseAttribute itemref="core:inverseAttribute"/>
  </Attribute>

  <Attribute itemName="core:unidirectional">
    <displayName>unidirectional</displayName>
    <description>TRUE if the value of this attribute points to another item, but that item has no attribute that points back to this item.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Boolean"/>
    <defaultValue>false</defaultValue>
  </Attribute>

  <Attribute itemName="core:attributeDefinedInDomainSchema">
    <displayName>defined in</displayName>
    <description>...add description here...</description>
    <superAttribute itemref="core:definedInDomainSchema"/>
    <inverseAttribute itemref="core:definedAttributes"/>
  </Attribute>
  
  <Attribute itemName="core:kinds" bootstrap="True">
    <displayName>kind</displayName>
    <issues>Brian suggests renaming this to "usedInKinds"</issues>
    <description>Which kinds use this attribute as one of their implied attributes, typically found on items of that Kind?</description>
    <cardinality>set</cardinality>
    <type itemref="core:Kind"/>
    <inverseAttribute itemref="core:attributes"/>
  </Attribute>

  <Attribute itemName="core:usedAsDisplayAttribute">
    <displayName>used as display attribute</displayName>
    <description>Which kinds use this attribute as the source for a human readable display name for items?  For example, in an Email Message item we might use the 'subject' attribute, and in a Contact item we might use the 'person name' attribute.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Kind"/>
    <inverseAttribute itemref="core:displayAttribute"/>
  </Attribute>

  <Attribute itemName="core:usedAsAdHocAttributeInItems">
    <displayName>ad hoc attribute in items</displayName>
    <description>What items have include this as an ad hoc attribute?</description>
    <cardinality>set</cardinality>
    <type itemref="core:Item"/>
    <hidden/>
    <inverseAttribute itemref="core:adHocAttributeList"/>
  </Attribute>

  <Attribute itemName="core:transitive">
    <displayName>transitive</displayName>
    <description>Is this a transitive relationship?  A relationship 'foo' is transitive when ((A.foo = B, and B.foo = C) means that (A.foo = C)). For example, the 'subclass' relationship is transitive.  If A is a subclass of B, and B is a subclass of C, then A is a subclass C.  Similar to the RDF/OWL property 'owl:TransitiveProperty'.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Boolean"/>
    <inheritFrom>core:referencePolicy.core:transitive</inheritFrom>
  </Attribute>

  <Attribute itemName="core:symmetric">
    <displayName>symmetric</displayName>
    <description>Is this a symmetric relationship?  A relationship 'foo' is symmetric when ((A.foo = B) means that (B.foo = A)). For example, the 'spouse' relationship is symmetric.  If A is the spouse of B, then B is the spouse of A.  Similar to the RDF/OWL property 'owl:SymmetricProperty'.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Boolean"/>
    <inheritFrom>core:referencePolicy.core:symmetric</inheritFrom>
  </Attribute>

  <Attribute itemName="core:copyPolicy" bootstrap="True">
    <displayName>copy policy</displayName>
    <description>If A has a reference to B, and vice-versa, what do we do when A is copied?  Do we copy B also (deep copy), or do we just set the new copy of A to point to the old version of B (shallow copy)?</description>
    <cardinality>single</cardinality>
    <type itemref="core:CopyPolicyEnum"/>
    <inheritFrom>core:referencePolicy.core:copyPolicy</inheritFrom>
  </Attribute>

  <Attribute itemName="core:deletePolicy" bootstrap="True">
    <displayName>delete policy</displayName>
    <description>If A has a reference to B, and vice-versa, what do we do when A is deleted?  Do we delete B also, or do we just remove B's reference to A, or do we delete B only if nobody else now references B?</description>
    <cardinality>single</cardinality>
    <type itemref="core:DeletePolicyEnum"/>
    <inheritFrom>core:referencePolicy.core:deletePolicy</inheritFrom>
  </Attribute>

  <Attribute itemName="core:referencePolicy">
    <displayName>relationship type</displayName>
    <description>What sort of relationship does this item have to the item pointed to by this attribute?</description>
    <cardinality>single</cardinality>
    <type itemref="core:ReferencePolicyEnum"/>
    <defaultValue>core:peer</defaultValue>
  </Attribute>

  <Attribute itemName="core:usedInAttributeChains">
    <displayName>used in attribute chains</displayName>
    <description>The set of the attribute chains that this attribute appears in.</description>
    <cardinality>set</cardinality>
    <inverseAttribute itemref="core:attributesInChain"/>
    <type itemref="core:AttributeChain"/>
  </Attribute>

  <Attribute itemName="core:inheritFrom">
    <displayName>inherit from</displayName>
    <description>Another attribute that this attribute inherits its value from.</description>
    <issues>Brian suggests changing the name to "inheritValuesFrom"</issues>
    <cardinality>single</cardinality>
    <inverseAttribute itemref="core:valuesInheritedBy"/>
    <type itemref="core:AttributeOrAttributeChain"/>
  </Attribute>

  <Attribute itemName="core:valuesInheritedBy">
    <displayName>values inherited by</displayName>
    <description>What other attributes inherit values from here?</description>
    <cardinality>set</cardinality>
    <inverseAttribute itemref="core:inheritFrom"/>
    <type itemref="core:Attribute"/>
  </Attribute>

  <Kind itemName="core:Attribute" bootstrap="True">
    <displayName>Attribute</displayName>
    <examples>('name', text string)</examples>
    <examples>('height', integer)</examples>
    <examples>('author', Person)</examples>
    <description>
      Kinds have Attribute Definitions. Each Attribute Definition can have some associated type, and the Attribute Values for that Attribute Definition are restricted to being values of that type.  An attribute's values can be completely unrestricted, or they can be restricted to some specific Kind, or some specific Type.  Attribute Definitions can also have default values, and default formats, derivation rules, etc.
      Some Attribute Definitions are global, and other Attribute Definitions are associated with a single Kind.  Also, some Attribute Definitions are associated with a single instance of an Item, rather than for a Kind.
    </description>
    <issues>It's not clear how best to associate an Attribute Definition with an Item or a Kind.  For example, let's say we have a Kind called "Book", and an Item called "The Cat in the Hat".  We want "Book" to have an Attribute Definition called 'author', and "The Cat in the Hat" has an 'author' of "Dr. Suess".  We also want to have a global Attribute Definition 'author', which is a sub-attribute of the dublin core attribute 'creator'.  The global 'author' can be shared, so that it is used for Books, Movies, Articles, and a wide variety of other Kinds.  The global 'author' has a shared semantic meaning, and it has a few shared properties, like the 'name': 'author'.  But in the context of our "Book", we want to say more about the 'author'.  Let's say that in the context of "Book", 'author' should be required, should have a cardinality of 'one' (not 'many'), and should have values of type "Person".  How do we associate that extra information with the notion of the 'author' Attribute Definition as it appears in the "Book" Kind?  One option is to have a global "Attribute Definition" for 'author' (which just has a name and maybe one or two other properties), and then have a separate "Attribute Binding" that associates 'author' and "Book" (which has a cardinality, type, etc.).  An second option is to use only "Attribute Definitions", not "Attribute Bindings", but to allow the "Book" to have its own "Attribute Definition" for 'author', which would have a pointer up to the global shared 'author', and which would provide additional properties (like cardinality) that we would interpret as _refining_ or _overriding_ or _extending_ the properties of the global 'author' Attribute Definition.  In this scenario, some Attribute Definitions would be associated with a particular Kind, while others would be associated with some more globally scoped item, like a Domain Schema.  To further complicate matters, individual items can have ad hoc attributes.  For example, a user could edit "The Cat in the Hat" and add an attribute 'foo' with a value of 'foobar', even though in general a "Book" doesn't have a 'foo' attribute.  So that means some Attribute Definitions can be associated with individual items.  We would probably like to make the assertion that each Attribute Definition should be defined in exactly one place, where that place is either an individual Item (like "The Cat in the Hat"), a Kind (like "Book"), or a Domain Schema (for global attributes). And each of those 3 places would have a different inverse attribute.  Since Domain Schemas and Kinds are both Items, you'd think we could just generally say that this thing is 'defined in' an Item.  But that won't work, because when this thing is 'defined in' a Kind, we need to explicitly use a different inverse attribute from the one used for Item, so that we can tell whether this thing is serving as an Attribute Definition for (a) the Item-ness of the Kind Item, or (b) the Kind-ness of the Kind Item.  Yikes!  Here's a quick example, to make that last point more concrete.  Let's say I have some Kind, like 'Book', and I just want to jot a little note on it using an ad hoc attribute called 'my little note about the Book Kind'.  If 'my little note about the Book Kind' is an Attribute Definition that's 'defined in' the Kind 'Book', how do we avoid misinterpreting it to mean that all books have a 'my little note about the Book Kind' attribute.</issues>
    <issues>Some Attributes have values that are literals, while others have values that are references to other Items. Right now, we instead just merge the 'Reference Definition' attributes up into 'Attribute Definition', which is a little sloppy.</issues>
    <superKinds itemref="core:Item"/>
    <displayAttribute itemref="core:displayName"/>
    <attributes itemref="core:displayName"/>
    <attributes itemref="core:description"/>
    <attributes itemref="core:examples"/>
    <attributes itemref="core:issues"/>
    <attributes itemref="core:hidden"/>
    <attributes itemref="core:superAttribute"/>
    <attributes itemref="core:subAttributes"/>
    <attributes itemref="core:type"/>
    <attributes itemref="core:cardinality"/>
    <attributes itemref="core:defaultValue"/>
    <attributes itemref="core:defaultFormat"/>
    <attributes itemref="core:restrictions"/>
    <attributes itemref="core:equivalentAttributes"/>
    <attributes itemref="core:required"/>
    <attributes itemref="core:derivationNotes"/>
    <attributes itemref="core:inverseAttribute"/>
    <attributes itemref="core:unidirectional"/>
    <attributes itemref="core:attributeDefinedInDomainSchema"/>
    <attributes itemref="core:kinds"/>
    <attributes itemref="core:usedAsDisplayAttribute"/>
    <attributes itemref="core:usedAsAdHocAttributeInItems"/>
    <attributes itemref="core:usedInAttributeChains"/>
    <attributes itemref="core:transitive"/>
    <attributes itemref="core:symmetric"/>
    <attributes itemref="core:copyPolicy"/>
    <attributes itemref="core:deletePolicy"/>
    <attributes itemref="core:referencePolicy"/>
    <attributes itemref="core:inheritFrom"/>
    <attributes itemref="core:valuesInheritedBy"/>
  </Kind>

<!-- Attribute Chain -->
  <Attribute itemName="core:attributesInChain">
    <displayName>attributes in chain</displayName>
    <description>An ordered list of the attributes that we should follow to hop from one item to the next.</description>
    <cardinality>list</cardinality>
    <inverseAttribute itemref="core:usedInAttributeChains"/>
    <type itemref="core:Attribute"/>
  </Attribute>

  <Kind itemName="core:AttributeChain">
    <displayName>Attribute Chain</displayName>
    <examples>employee.department.departmentManager.lastName</examples>
    <superKinds itemref="core:Item"/>
    <attributes itemref="core:attributesInChain"/>
    <attributes itemref="core:usedAsDisplayAttribute"/>
    <attributes itemref="core:valuesInheritedBy"/>
  </Kind>

<!-- HeavyweightEnumeration -->
  <Attribute itemName="core:appearsInEnumeration">
    <displayName>appears in enumeration</displayName>
    <description>This item is one of the possible values in these enumerations.</description>
    <cardinality>set</cardinality>
    <type itemref="core:HeavyweightEnumeration"/>
    <inverseAttribute itemref="core:values"/>
  </Attribute>

  <Attribute itemName="core:values">
    <displayName>values</displayName>
    <description>An ordered list of the values the possible values for this enum, each of which is an item.</description>
    <cardinality>list</cardinality>
    <type itemref="core:Item"/>
    <inverseAttribute itemref="core:appearsInEnumeration"/>
  </Attribute>

  <Kind itemName="core:HeavyweightEnumeration">
    <displayName>Heavyweight Enumeration</displayName>
    <examples>In a bug tracking system, you might have a 'bug priority' enum, with values of 'high', 'medium', and 'low'</examples>
    <issues>If we set things up this way, how do we do strong typing?  If 'bug priority' is just an Item, not a Kind, then on the Kind for 'Bug', how do we have an Attribute Definition that's strongly typed to point to a 'bug priority' value?  Maybe we need to make Enum be a Subkind of Kind instead of a Subkind of Item, and then have 'Bug Priority' be a SubKind of Enum with an attribute that points to its list of instances (the 'extension' of the Kind).</issues>
    <superKinds itemref="core:Kind"/>
    <abstract/>
    <attributes itemref="core:values"/>
  </Kind>

<!-- Cardinality Enum -->
  <HeavyweightEnumeration itemName="core:CardinalityEnum">
    <displayName>Cardinality Enum</displayName>
    <element>core:single</element>
    <element>core:set</element>
    <element>core:list</element>
  </HeavyweightEnumeration>

  <Item itemName="core:single"/>
  <Item itemName="core:set"/>
  <Item itemName="core:list"/>

<!-- Copy Policy Enum -->
  <HeavyweightEnumeration itemName="core:CopyPolicyEnum">
    <displayName>Copy Policy Enum</displayName>
    <element>core:deepCopy</element>
    <element>core:shallowCopy</element>
    <element>core:superShallowCopy</element>
  </HeavyweightEnumeration>

  <Item itemName="core:deepCopy"/>
  <Item itemName="core:shallowCopy"/>
  <Item itemName="core:superShallowCopy"/>

<!-- Delete Policy Enum -->
  <HeavyweightEnumeration itemName="core:DeletePolicyEnum">
    <displayName>Delete Policy Enum</displayName>
    <element>core:cascadeDelete</element>
    <element>core:strongReference</element>
    <element>core:weakReference</element>
  </HeavyweightEnumeration>

  <Item itemName="core:cascadeDelete"/>
  <Item itemName="core:strongReference"/>
  <Item itemName="core:weakReference"/>

<!-- Reference Policy Enum -->
  <HeavyweightEnumeration itemName="core:ReferencePolicyEnum">
    <displayName>Reference Policy Enum</displayName>
    <element>core:peer</element>
    <element>core:parent</element>
    <element>core:children</element>
    <element>core:owns</element>
    <element>core:ownedBy</element>
    <element>core:equivalent</element>
  </HeavyweightEnumeration>

<!-- Reference Policy -->
  <Kind itemName="core:ReferencePolicy">
    <displayName>Reference Policy</displayName>
    <superKinds itemref="core:Item"/>
    <attributes itemref="core:copyPolicy"/>
    <attributes itemref="core:deletePolicy"/>
    <attributes itemref="core:transitive"/>
    <attributes itemref="core:symmetric"/>
  </Kind>

  <ReferencePolicy itemName="core:peer">
    <displayName>Peer</displayName>
    <copyPolicy>core:superShallowCopy</copyPolicy>
    <deletePolicy>core:strongReference</deletePolicy>
  </ReferencePolicy>

  <ReferencePolicy itemName="core:parent">
    <displayName>Parent</displayName>
    <copyPolicy>core:shallowCopy</copyPolicy>
    <deletePolicy>core:strongReference</deletePolicy>
    <transitive>true</transitive>
  </ReferencePolicy>

  <ReferencePolicy itemName="core:children">
    <displayName>Children</displayName>
    <copyPolicy>core:superShallowCopy</copyPolicy>
    <deletePolicy>core:strongReference</deletePolicy>
    <transitive>true</transitive>
  </ReferencePolicy>

  <ReferencePolicy itemName="core:owns">
    <displayName>Owns</displayName>
    <copyPolicy>core:deepCopy</copyPolicy>
    <deletePolicy>core:cascadeDelete</deletePolicy>
  </ReferencePolicy>

  <ReferencePolicy itemName="core:ownedBy">
    <displayName>Owned By</displayName>
    <copyPolicy>core:superShallowCopy</copyPolicy>
    <deletePolicy>core:weakReference</deletePolicy>
  </ReferencePolicy>

  <ReferencePolicy itemName="core:equivalent">
    <displayName>Eqivalent</displayName>
    <copyPolicy>core:shallowCopy</copyPolicy>
    <deletePolicy>core:strongReference</deletePolicy>
    <transitive>true</transitive>
    <symmetric>true</symmetric>
  </ReferencePolicy>

<!-- Attribute Format -->
  <Attribute itemName="core:appliesToType">
    <displayName>applies to type</displayName>
    <description>Which type is this a display format for?</description>
    <cardinality>single</cardinality>
    <type itemref="core:Type"/>
    <inverseAttribute itemref="core:formats"/>
  </Attribute>

  <Attribute itemName="core:formatString">
    <displayName>format string</displayName>
    <examples>DD MMM YYYY</examples>
    <examples>MM/DD/YY HH:MM</examples>
    <examples>NN%</examples>
    <examples>$ N,NNN.NN</examples>
    <cardinality>single</cardinality>
    <type itemref="core:AnyString"/>
  </Attribute>

  <Attribute itemName="core:formatFields">
    <displayName>format string</displayName>
    <description>A list of the attribute fields used in the format string.</description>
    <cardinality>list</cardinality>
    <type itemref="core:Field"/>
  </Attribute>

  <Attribute itemName="core:usedAsDefaultFormat">
    <displayName>used as default format</displayName>
    <description>What attributes use this as their default format?</description>
    <cardinality>set</cardinality>
    <type itemref="core:Attribute"/>
    <inverseAttribute itemref="core:defaultFormat"/>
  </Attribute>

  <Kind itemName="core:AttributeFormat">
    <displayName>Attribute Format</displayName>
    <examples>DD MMM YYYY</examples>
    <examples>MM/DD/YY HH:MM</examples>
    <examples>NN%</examples>
    <examples>$ N,NNN.NN</examples>
    <issues>What's the relationship, if any, between this AttributeFormat and the CPIA notion of a display phrase?</issues>
    <superKinds itemref="core:Item"/>
    <displayAttribute itemref="core:formatString"/>
    <attributes itemref="core:appliesToType"/>
    <attributes itemref="core:formatString"/>
    <attributes itemref="core:formatFields"/>
    <attributes itemref="core:usedAsDefaultFormat"/>
  </Kind>

<!-- Attribute Restriction -->
  <Attribute itemName="core:appliesToAttribute">
    <displayName>applies to</displayName>
    <description>Which attribute is this a restriction on?</description>
    <cardinality>single</cardinality>
    <required/>
    <type itemref="core:Attribute"/>
    <inverseAttribute itemref="core:restrictions"/>
    <referencePolicy>ownedBy</referencePolicy>
  </Attribute>

  <Attribute itemName="core:restrictionInfo">
    <displayName>restriction</displayName>
    <description>What is the actual restriction? </description>
    <issues>(@@@ -- If we want to support restrictions, this needs to be not a 'Simple String', but rather some more complicated machine-readable specification of the restriction.</issues>
    <cardinality>single</cardinality>
    <required/>
    <type itemref="core:SimpleString"/>
  </Attribute>

  <Kind itemName="core:AttributeRestriction">
    <displayName>Attribute Restriction</displayName>
    <examples>'rainfall' should be a non-negative number</examples>
    <examples>'age' should be over 21</examples>
    <examples>'start-time' should come before 'end-time'</examples>
    <examples>my 'mother' should have a 'birth-date' prior to my 'birth-date'</examples>
    <examples>my 'mother' should not be the 'daughter' of my 'son'</examples>
    <description>
      See the wiki page for DataModelIssues#Restrictions_on_Attributes.
    </description>
    <issues>How do we actually represent the restriction info?</issues>
    <issues>Should we change the name to be 'Expectation' instead of 'Restriction'?</issues>
    <superKinds itemref="core:Item"/>
    <displayAttribute itemref="core:restrictionInfo"/>
    <attributes itemref="core:appliesToAttribute"/>
    <attributes itemref="core:restrictionInfo"/>
  </Kind>

<!-- Derivation Rule ... not in current plans
  <Attribute itemName="core:derivedAttribute">
    <displayName>derived attribute</displayName>
    <description>Which attribute does this derivation rule apply to?</description>
    <cardinality>single</cardinality>
    <type itemref="core:DerivationRule"/>
    <inverseAttribute itemref="core:derivation"/>
    <referencePolicy>ownedBy</referencePolicy>
  </Attribute>
  
  <Attribute itemName="core:formula">
    <displayName>formula</displayName>
    <description>What is the actual derivation rule?</description>
    <issues>(@@@ -- not clear how to represent this.</issues>
    <cardinality>single</cardinality>
    <required/>
    <type itemref="core:SimpleString"/>
  </Attribute>

  <Kind itemName="auto:DerivationRule">
    <displayName>Derivation Rule</displayName>
    <superKinds itemref="core:Item"/>
    <displayAttribute itemref="core:formula"/>
    <attributes itemref="core:derivedAttribute"/>
    <attributes itemref="core:formula"/>
  </Kind>
-->
 
<!-- Note -->
  <Attribute itemName="core:noteAppliesTo">
    <displayName>item</displayName>
    <description>The item or items being annotated</description>
    <cardinality>set</cardinality>
    <type itemref="core:Item"/>
    <inverseAttribute itemref="core:note"/>
  </Attribute>

  <Attribute itemName="core:content">
    <displayName>content</displayName>
    <description>The annotation itself</description>
    <cardinality>single</cardinality>
    <type itemref="core:PolyglotString"/>
  </Attribute>

  <Kind itemName="core:Note">
    <displayName>Note</displayName>
    <examples>'They called on Tuesday and said it would be ready by Friday at noon.'</examples>
    <examples>'This is probably trash now -- feel free to delete it.'</examples>
    <description>
      An Note represents a note that a user adds to an e-mail message or to any other item. An annotation might also represent an actual editing change to the original message itself. See EditingReceivedEmail. See MessageAnnotation.
    </description>
    <issues>Are Notes always associated with exactly 1 Item?</issues>
    <issues>Can a selection of 5 Items be annotated with 1 Note?</issues>
    <issues>Can a particular attribute of an Item be the subject of a note? (example: I select the 'population' field of the 'Canada' Item, and I add the annotation: 'The U.N. says this is now over 32 million')</issues>
    <issues>Is a note just a bunch of text?</issues>
    <issues>Can an note represent an actual edit to the original Item? (example: I edit the body of an e-mail message and change a misspelling.)</issues>
    <superKinds itemref="core:Item"/>
    <displayAttribute itemref="core:content"/>
    <attributes itemref="core:noteAppliesTo"/>
    <attributes itemref="core:content"/>
  </Kind>

<!-- Operator -->
  <Attribute itemName="core:itemsCreated">
    <displayName>items created</displayName>
    <description>What items has this operator created?</description>
    <cardinality>set</cardinality>
    <type itemref="core:Item"/>
    <hidden/>
    <inverseAttribute itemref="core:createdBy"/>
  </Attribute>

  <Kind itemName="core:Operator">
    <displayName>Operator</displayName>
    <examples>Vanessa Kline</examples>
    <examples>Kevin Rulwa's e-mail agent</examples>
    <description>
      Someone or something that can create and edit items.
    </description>
    <superKinds itemref="core:Item"/>
    <abstract/>
    <attributes itemref="core:description"/>
    <attributes itemref="core:itemsCreated"/>
  </Kind>

<!-- VersionInfo -->
  <Attribute itemName="core:versionInfo">
    <displayName>version info</displayName>
    <description>A simple version number, or some simple version string, or a version info item, or a URL that points to a page with version info.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Anything"/>
  </Attribute>

  <Attribute itemName="core:currentItem">
    <displayName>current item</displayName>
    <description>The item that this is the version info for.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Item"/>
    <inverseAttribute itemref="core:version"/>
  </Attribute>

  <Kind itemName="core:Version">
    <displayName>Version</displayName>
    <description>
      A minimal placeholder for storing version info.  Sub-kinds of this kind can add more sophisiticated representations for doing high-tech versioning and keeping track of version changes.
    </description>
    <superKinds itemref="core:Item"/>
    <displayAttribute itemref="core:versionInfo"/>
    <attributes itemref="core:versionInfo"/>
    <attributes itemref="core:currentItem"/>
  </Kind>

<!-- Foreign Item -->
  <Attribute itemName="core:sourceItem">
    <displayName>source item</displayName>
    <description>Type is probably a 'string' or a 'URL' or some kind of item with more detailed info. In any case, it's whatever info we need to keep track of in order to find the original information from the foreign data source.</description>
    <cardinality>single</cardinality>
    <type itemref="core:AnyString"/>
    <type itemref="core:URL"/>
    <type itemref="core:Anything"/>
  </Attribute>

  <Attribute itemName="core:rawSnapshot">
    <displayName>raw snapshot</displayName>
    <description>This attribute is jus a place for keeping a copy of the raw information, just the way it was when we first read it from the foreign data source.</description>
    <cardinality>single</cardinality>
    <type itemref="core:AnyString"/>
    <type itemref="core:Blob"/>
    <type itemref="core:Anything"/>
  </Attribute>

   <Attribute itemName="core:localCopy">
    <displayName>local copy</displayName>
    <description>The Chanlder Item that's a copy of the information from this foreign source.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Item"/>
    <inverseAttribute itemref="core:proxyFor"/>
    <referencePolicy>ownedBy</referencePolicy>
  </Attribute>

  <Kind itemName="core:ForeignItem">
    <displayName>Foreign Item</displayName>
    <description>...add description here...</description>
    <superKinds itemref="core:Item"/>
    <displayAttribute itemref="core:sourceItem"/>
    <attributes itemref="core:sourceItem"/>
    <attributes itemref="core:rawSnapshot"/>
    <attributes itemref="core:localCopy"/>
  </Kind>

<!-- Anything -->
  <Alias itemName="core:Anything">
    <displayName>Anything</displayName>
    <description>
      If an attribute is of type 'Anything', the values are allowed to be any type: any 'Item' or any 'Literal'.
    </description>
    <aliasFor itemref="core:Item"/>
    <aliasFor itemref="core:AnyLiteral"/>
  </Alias>

<!-- Any Literal -->
  <Alias itemName="core:AnyLiteral">
    <displayName>Any Literal</displayName>
    <examples>25</examples>
    <examples>0.75</examples>
    <examples>TRUE</examples>
    <examples>'this is a simple string'</examples>
    <description>
      An alias for all the literal types such as Integer, Float, Boolean, and String.
    </description>
    <aliasFor itemref="core:Number"/>
    <aliasFor itemref="core:Boolean"/>
    <aliasFor itemref="core:Blob"/>
    <aliasFor itemref="core:AnyString"/>
    <aliasFor itemref="core:AnyDateTime"/>
    <aliasFor itemref="core:AnyURL"/>
  </Alias>

<!-- Any String -->
  <Alias itemName="core:AnyString">
    <displayName>Any String</displayName>
    <description>
      If an attribute is of type 'AnyString', the values are allowed to be any sort of string type: an 'Simple String' (like a 'Unicode String'), or a 'Compound String' (like a 'Polyglot String').
    </description>
    <aliasFor itemref="core:String"/>
    <aliasFor itemref="core:StringWithReferences"/>
    <aliasFor itemref="core:PolyglotString"/>
  </Alias>

<!-- Any Datetime -->
  <Alias itemName="core:AnyDatetime">
    <displayName>Any Datetime</displayName>
    <description>
      If an attribute is of type 'AnyDatetime', the values are allowed to be any sort of datetime type: an 'DateTime' or a 'RelativeDateTime'.
    </description>
    <aliasFor itemref="core:DateTime"/>
    <aliasFor itemref="core:RelativeDateTime"/>
  </Alias>

<!-- Number -->
  <Alias itemName="core:Number">
    <displayName>Number</displayName>
    <examples>25</examples>
    <examples>0.75</examples>
    <aliasFor itemref="core:Integer"/>
    <aliasFor itemref="core:Float"/>
    <aliasFor itemref="core:Long"/>
  </Alias>

<!-- Integer -->
  <Type itemName="core:Integer" bootstrap="True">
    <displayName>Integer</displayName>
    <examples>25</examples>
    <examples>75</examples>
  </Type>

<!-- Float -->
  <Type itemName="core:Float" bootstrap="True">
    <displayName>Float</displayName>
    <examples>2.5</examples>
    <examples>0.75</examples>
  </Type>

<!-- Long -->
  <Type itemName="core:Long" bootstrap="True">
    <displayName>Long</displayName>
  </Type>

<!-- Boolean -->
  <Type itemName="core:Boolean" bootstrap="True">
    <displayName>Boolean</displayName>
    <examples>True</examples>
    <examples>False</examples>
  </Type>

<!-- Blob -->
  <Type itemName="core:Blob">
    <displayName>Blob -- Binary large object</displayName>
    <description>
      A sequence of bytes.  A blob of binary data, like you would find inside a gif or an mp3.
    </description>
  </Type>

<!-- Symbol -->
  <Type itemName="core:Symbol" bootstrap="True">
    <displayName>Symbol</displayName>
    <description>
      A short ASCII string with no spaces or special characters.  Something suitable for using as a variable name in Python or Java.
    </description>
  </Type>

<!-- RepositoryContainmentPath -->
<!-- this is an *intrinsic attribute*, not a *Chandler attribute*
  <Type itemName="core:ItemPath">
    <displayName>Item Path</displayName>
    <examples>//home/kitchen/fridge/ketchup</examples>
    <description>
      Every item can be found in the repository through its path, a / separated concatenation of the item's name and its parent ancestry. A path to an item can be expressed relative to the repository in which case it begins with //. A path to an item can be expressed relative to the item's root in which case it begins with /. Or it can be expressed relative to an item in which case it begins with a name.
    </description>
  </Type>
-->

<!-- UUID -->
  <Type itemName="core:UUID" bootstrap="True">
    <displayName>UUID</displayName>
    <examples>e2d03cb4-9d58-11d7-d179-000393db837c</examples>
    <description>
      Every item can be found in the repository through its UUID, a Universally Unique IDentifier. The UUID is a 128-bit number implemented following the UUID IETF specification draft.
    </description>
  </Type>

<!-- Any URL -->
  <Alias itemName="core:AnyURL">
    <displayName>Any URL</displayName>
    <examples>http://www.osafoundation.org/</examples>
    <examples>rap://esu.edu/~pat/contacts/clive</examples>
    <description>
      A conventional URL.
    </description>
    <aliasFor itemref="core:UnicodeString"/>
  </Alias>

<!-- DateTime -->
  <Type itemName="core:DateTime" bootstrap="True">
    <displayName>DateTime</displayName>
    <examples>2003/08/11 3:34:45</examples>
    <description>
      A datetime that's required to have valid values for all fields: YYYY/MM/DD hh:mm:ss. A "rigid" datetime like this could be stored as an integer like 'number of seconds since 1970', whereas a Flexible Datetime can not, because it may not have some fields: year or day or time of day.
    </description>
    <issues>Brian suggests renaming this to be "Rigid Datetime"</issues>
    <field>
      <displayName>year</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>month</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>day</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>hour</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>minute</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>second</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>timezone</displayName>
      <type itemref="core:Timezone"/>
    </field>
  </Type>

<!-- RelativeDateTime -->
  <Type itemName="core:RelativeDateTime">
    <displayName>RelativeDateTime</displayName>
    <description>
      'datetime' = 'date', 'time', 'timezone'
    </description>
    <issues>Brian suggests renaming this to be "Flexible Datetime"</issues>
    <field>
      <displayName>year</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>years</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>month</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>months</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>weekday</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>weeks</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>day</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>days</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>hour</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>hours</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>minute</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>minutes</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>second</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>seconds</displayName>
      <type itemref="core:Integer"/>
    </field>
  </Type>

<!-- DateTimeDelta -->
  <Type itemName="core:DateTimeDelta">
    <displayName>DateTimeDelta</displayName>
    <description>
      'duration' = 'day', 'hour', 'minute', 'second'
    </description>
    <issues>Brian suggests renaming this to be "Duration"</issues>
    <field>
      <displayName>day</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>hour</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>minute</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>second</displayName>
      <type itemref="core:Integer"/>
    </field>
  </Type>

<!-- String -->
  <Type itemName="core:String" bootstrap="True">
    <displayName>String</displayName>
    <examples>'this is a simple string'</examples>
    <examples>'the future of ideas'</examples>
    <description>
      A simple unicode text string.  Strings can include words that have links -- links to Chandler items or traditional web browser URL links.
    </description>
  </Type>

<!-- Unicode String -->
  <Alias itemName="core:UnicodeString">
    <displayName>Unicode String</displayName>
    <description>
      Any Unicode string.  Just plain text, with no special markup that Chandler knows anything about.
    </description>
    <aliasFor itemref="core:String"/>
  </Alias>

<!-- Rich Text String -->
  <Alias itemName="core:RichTextString">
    <displayName>Rich Text String</displayName>
    <description>
      A string where some of the words might be bold, or italic, or underlined, or drawn in red.  The string is stored with some kind of graphical markup info that Chandler knows how to parse when it displays the string.  For markup, we could use RTF, or some subset of HTML, or something else entirely.
    </description>
    <aliasFor itemref="core:UnicodeString"/>
  </Alias>

<!-- String with References -->
  <Attribute itemName="core:stringWithReferenceTags">
    <displayName>string with reference tags</displayName>
    <description>The text string itself, including some special tags to mark the substrings that have references.</description>
    <cardinality>single</cardinality>
    <type itemref="core:UnicodeString"/>
  </Attribute>

  <Attribute itemName="core:references">
    <displayName>references</displayName>
    <description>A list of the items that the string has links to.</description>
    <cardinality>list</cardinality>
    <type itemref="core:Item"/>
  </Attribute>

  <Kind itemName="core:StringWithReferences">
    <displayName>String with References</displayName>
    <examples>'Lunch with [_1]Sally[/_1] and [_2]Jim[/_2]'</examples>
    <description>
      A string that includes 'references' to other Chandler Items.
    </description>
    <issues>The interaction between this 'String with References' and 'Polyglot String' could be complicated. Maybe we just shouldn't bother supporting Polyglot Strings with References.</issues>
    <issues>What's the relationship between this 'String with References' and the notion of a 'display phrase'?</issues>
    <attributes itemref="core:stringWithReferenceTags"/>
    <attributes itemref="core:references"/>
  </Kind>


<!-- Polyglot String -->
  <Attribute itemName="core:langaugeStrings">
    <displayName>strings</displayName>
    <description>this is like a Python dictionary, with string translations keyed by language</description>
    <cardinality>dict</cardinality>
    <type itemref="core:UnicodeString"/>
  </Attribute>

  <Kind itemName="core:PolyglotString">
    <displayName>Polyglot String</displayName>
    <examples>(en, 'Hello World') / (de, 'Guten Tag Welt') / ...</examples>
    <description>
      A Polyglot String represents a collection of related strings, with one string for each Language that the string has been translated into.
    </description>
    <superKinds itemref="core:Item"/>
    <attributes itemref="core:langaugeStrings"/>
  </Kind>

</DomainSchema>

