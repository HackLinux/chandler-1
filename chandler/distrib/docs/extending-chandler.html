<html>
<head>
<title>Extending Chandler</title>

<link rel=StyleSheet href="osaf.css" type="text/css"/>

</head>
<body>

<h1>Extending Chandler</h1>
<h4>Morgen Sagen
<br />
Open Source Applications Foundation</h4>

<p>This document explains how to extend Chandler's functionality by
adding new schema, data, and behavior through add-ons called "Parcels".
First we will introduce the <a href=#repo>Chandler repository</a>, then
cover the <a href=#parcels>Parcel loading framework</a>, and finish
with the basics of <a href=#cpia>creating a simple user interface</a>.
While reading this document, you might also want to have the <a
href=http://osafoundation.org/docs/current/model/repository/schema/sentences.html>core
data model documentation</a> and <a
href=http://osafoundation.org/docs/current/api/>Chandler API
documentation</a> nearby for reference.  </p>

<br />

<div class="legend">
<b>Document Conventions</b>

<p>Whenever XML is presented it will appear in a grey box, and text that is to be replaced by you will be highlighted in red:</p>

<pre class=xml>
&lt;Element attribute="<span class='replace'>example</span>"/&gt;
</pre>

<p>Examples of Python code will be presented in a yellow box:</p>

<pre class=codebox>
item = rep.find("//Schema/Core/Kind")
</pre>

<p>
Filesystem paths will be in fixed-width font: <span class='file'>Chandler/parcels/OSAF</span>
</p>
<p>
Chandler repository paths will be fixed-width bold: <span class='path'>//root/path</span>
</p>
</div>

<br />

<a name=repo>
<h2>Introduction to the Repository</h2>

<h3>Items</h3>

<p>Chandler's repository stores and retrieves persistent objects
called "items"; these items are arranged in a hierarchy, and
are addressable either by a unique identifier (UUID) or by
their path within the repository.  Repository paths begin with
double-slashes (<span class='path'>//</span>) and use single
slashes (<span class='path'>/</span>) as separators (e.g. <span
class='path'>//Schema/Core/Kind</span>).  Through the repository
API you can retrieve an item by its path (or by its UUID):
</p>
<pre class=codebox>
item = rep.find("//Schema/Core/Kind")
</pre>

<p>
Once you have an item you can ask it for its path or UUID.  An item's
path may change if it is moved to another part of the repository tree
but its UUID always remains the same.
</p>

<pre class=codebox>
path = item.getItemPath( )
uuid = item.getUUID( )
</pre>

<p>
Since items are stored in a hierarchy, it is useful to ask an item
for its parent, or to iterate through an item's children:
</p>

<pre class=codebox>
parentItem = item.getItemParent( )
for childItem in parentItem:     // iterate through child items
    print childItem.getItemName( )
</pre>

<h3>Schema</h3>

<p> There are special items called "kinds" which are Chandler's version of
object-oriented "classes".  Items can be thought of as instances of kinds,
and take on the characteristics described by their kind. For example,
a kind determines what attributes an item has and what code implements an
item's behavior. An attribute contains meta information including its name
(how you refer to it in Python), cardinality (single or multi-valued) and
type (what kind of value can be assigned).  Everything in the repository
is an item, including the kinds and attributes.  You can determine the
kind of an item by looking at its ".kind" Python attribute: </p>

<pre class=codebox>
item = rep.find("//parcels/OSAF")
print item.kind.getItemPath( )

<i>... //Schema/Core/Parcel</i>
</pre>
<p>The above example shows that the item, <span
class='path'>//parcels/OSAF</span>, is a kind of <span
class='path'>//Schema/Core/Parcel</span>.  Therefore the item
has the attributes defined for that kind, which can be determined
by looking at the kind's ".attributes" (although
you also have to ask each of the kind's super-kinds in order to
get the inherited attributes; there is a helper function, <span
class='code'>repository.parcel.Util.GetAttributes( )</span> which does
that for you).  You can use <span class='code'>repository.parcel.Util.PrintItem( )</span> to display an item on stdout:</p>

<pre class=codebox>
from repository.parcel.Util import PrintItem
PrintItem("//Schema/Core/Parcel", rep)
 
<i>... //Schema/Core/Parcel
        classes: (dict)
            python: &lt;class 'repository.parcel.Parcel.Parcel'&gt;
        superKinds: (dict)
            //Schema/Core/Item
        attributes:
            //Schema/Core/Parcel/author
            //Schema/Core/Parcel/publisher
            //Schema/Core/Parcel/status
            //Schema/Core/Parcel/summary
            //Schema/Core/Parcel/icon
            //Schema/Core/Parcel/version
            //Schema/Core/Parcel/createdOn
            //Schema/Core/Parcel/modifiedOn
            //Schema/Core/displayName (from //Schema/Core/Item)
            //Schema/Core/description (from //Schema/Core/Item)
            //Schema/Core/issues (from //Schema/Core/Item)
            //Schema/Core/examples (from //Schema/Core/Item)
            //Schema/Core/Item/kind (from //Schema/Core/Item)
        kind: //Schema/Core/Kind</i>
</pre>

<p>The above output shows you the eight attributes that are defined
directly on that kind, and the five that are inherited from the <span
class='path'>//Schema/Core/Item</span> kind.  Looking more closely at one
of the attributes, <span class='path'>//Schema/Core/Parcel/author</span>...
</p>

<pre class=codebox>
PrintItem("//Schema/Core/Parcel/author", rep)
 
<i>... //Schema/Core/Parcel/author
        cardinality: single &lt;type 'str'&gt;
        type: //Schema/Core/String
        kind: //Schema/Core/Attribute
        kinds: (dict)
            //Schema/Core/Parcel</i>
</pre>

<p>...we can see that this attribute can be assigned an item of kind
<span class='path'>//Schema/Core/String</span> (this is specified by the
attribute's "type"), and that only one value can be assigned (because
the "cardinality" is "single").  An attribute can also be a list or a
dictionary, by setting its cardinality to either "list" or "dict".
The "attribute attributes" such as "type" and "cardinality" are referred to
as "attribute aspects".  Some aspects that can be specified are:
<ul>
<li><span class=code>cardinality</span>:  Set to "single", "list", or "dict"; default = single
<li><span class=code>defaultValue</span>:  The value to return when there is no value set for this attribute. This default value is owned by the attribute item and is read-only when it is a collection; default = an attribute has no default value
<li><span class=code>inheritFrom</span>:  A "chain" of traversed attributes to inherit a value from.  For example, if "person" has a "father" attribute, you could create another attribute called "greatgrandfather" whose inheritFrom is set to "father.father.father" -- retrieving the value of greatgrandfather would follow the chain of attribute names; default = none
<li><span class=code>initialValue</span>:  Similar to <span class=code>defaultValue</span> except the initial value is set as the value of the attribute the first time it is returned.  A copy of the initial value is set when it is a collection; default = none
<li><span class=code>otherName</span>:  By setting the otherName aspect of two attributes to each other you are specifying they are the two endpoints of a bi-directional relationship; default = none
<li><span class=code>persist</span>:  Specifies whether the attribute's value is persisted when the owning item is saved; default = True
<li><span class=code>required</span>:  Set this aspect to True to signify this attribute requires a value.  A <span class=code>commit( )</span> or <span class=code>check( )</span> will fail if a required attribute is missing a value; default = False
<li><span class=code>type</span>:  Specifies the type of value that can be assigned to this attribute; default = any type of value can be assigned.
</ul>
</p>
<p>See the API documentation for more details regarding <a href=http://osafoundation.org/docs/current/api/repository.item.Item.Item-class.html#getAttributeAspect>attribute aspects</a>.</p>

<!--
<p>The repository core schema lives in <span class='path'>//Schema/Core</span>. Application-specific schema will typically live under <span class='path'>//parcels</span> as you will see later in this document.</p>
-->

<h3>Literals</h3>

<p>Once you have defined your schema (kind and attribute items), you
can put it to work by creating items based on those kinds and assigning
values to their attributes.  The values you assign must be of the correct
type for each attribute or else repository commits will fail (that's when
schema validation takes place).  There is also a <span class='code'>check( )</span> method for performing validation prior to a commit.</p>

<pre class=codebox>
parcelKind = rep.find("//Schema/Core/Parcel")
myParcel = parcelKind.newItem("myParcel", parentItem)
myParcel.author = 42
rep.check( )

<i>... Value 3 of type &lt;type 'int'&gt; in attribute author on 
       //myParcel is not recognized by type //Schema/Core/String
       False</i>

myParcel.author = "Morgen Sagen"
rep.check( )

<i>... True</i>
</pre>

<p>For attributes whose cardinality is "list", such as <span class='path'>//Schema/Core/issues</span>, the attribute can be treated just like a standard
python list object:</p>

<pre class=codebox>
myParcel.issues = ["a", "b", "c"]
print myParcel.issues

<i>... ['a', 'b', 'c']</i>

myParcel.issues.append("z")
del(myParcels.issues[1])
print myParcel.issues

<i>... ['a', 'c', 'z']</i>
</pre>

<p>Similarly, "dict" attributes behave just like standard python dicts.</p>

<pre class=codebox>
myParcel.dictattr = { "a":"a1", "b":"b1", "c":"c1" }
print myParcel.dictattr

<i>... {'a': 'a1', 'c': 'c1', 'b': 'b1'}</i>

print myParcel.dictattr.keys()

<i>... ['a', 'c', 'b']</i>
</pre>
<h3>Item References</h3>

<p>The Chandler repository supports bi-directional links between
items called "item references" or just "refs" for short; this
involves pairing an attribute with its "inverse".  For example,
<span class='path'>//Schema/Core/Kind</span> has an attribute, <span
class='path'>//Schema/Core/Kind/superKinds</span>, used to specify which
kind(s) to inherit from.  There is a corresponding inverse attribute,
<span class='path'>//Schema/Core/Kind/subKinds</span>, indicating which
kinds inherit from a given kind.  These two attributes can be thought
of as the two endpoints of a bi-directional relationship.  This inverse
attribute pairing is done by assigning each attribute to the other's
"otherName" Python attribute when defining the schema.  Once paired up,
assigning through one of the attributes will automatically make the
corresponding inverse assignment.  In addition, sever one end of the
link and the other end cuts itself off automatically -- no dangling
pointers.</p>

<p>For example, say that a certain kind has two attributes "givesTo" and
"takesFrom" which have been defined as inverses of each other, and we have two items of that kind, <span class='code'>item1</span>
and <span class='code'>item2</span>:</p>

<pre class=codebox>
item1.givesTo = item2
print item2.takesFrom.getItemName()

<i>... item1</i>
</pre>

<p>When we assigned <span class='code'>item2</span> as the value of <span class='code'>item1</span>'s "givesTo" attribute, the repository automatically made
the inverse assigmnent to <span class='code'>item2</span>'s "takesFrom" attribute.</p>

<p>If an attribute does not have an inverse (otherName) attribute, then a
one-way reference called a "singleref" will be created during assignment;
however this sort of reference doesn't scale well and should usually be
avoided.</p>

<p>Item reference attributes can have a cardinality of "single" or "list";
those with cardinality "list" which are paired with an inverse attribute
are called "reference collections" and have some special properties.
Reference collections can be thought of as ordered sets -- they have
no duplicates.  Unlike a list or array, you need to access items of the
collection by iterating on the attribute -- you can't directly access
item N from the collection. </p>

<p>Say we have a kind with a two attributes "members" and "memberOf",
both of cardinality "list", and both inverses of each other;
<span class='code'>item1</span> through
<span class='code'>item4</span>
are instances of that kind:
</p>

<pre class=codebox>
// Three different ways to add items to a ref collection:
item1.members = [item2]
item1.members.append(item3)
item1.addValue("members", item4)

for item in item1.members:
    print item.getItemName()

<i>... item2
    item3</i>

for item in item2.memberOf:
    print item.getItemName()

<i>... item1</i>
</pre>

<p>The above example shows a few ways to add items to a reference
collection.  One benefit to using the <span class=code>addValue(
)</span> method is the collection will be created for you if it
doesn't already exist.  To remove an item from a collection use <span
class=code>removeItem( )</span>; to see if an item is in a collection,
use the <span class=code>in</span> operator:</p>

<pre class=codebox>
item1.members.removeItem(item2)

print item2 in item1.members

<i>... False</i>

print item3 in item1.members

<i>... True</i>
</pre>

<p>To rearrange the order of items in the collection, use the <span class=code>placeItem( )</span> method.</p>

<!--
<pre class='annotation'>
Notes from talking with andi:
a reference collection is an attribute whose cardinality is 'list' and
has an 'otherName'
it's semantically an ordered set 
  - it contains no duplicates
  - you have to iterate on it to access the elements
  - or check for membership via the "in" operator
  - add to the collection, either with item.addValue("attrname", otherItem) 
     or via item.attrname.append(otherItem)
     but addValue will create the collection if it doesn't yet exist
  - remove from the collection (using item.ref_dict.removeItem(item2))
  - rearrange the collection with placeItem()

Regarding attribute aspects:
  - inheritFrom is a a way to inherit an attribute value from another attribute.
   (imagine you want the address of your son.  Your son lives with you.  
    son.address is set to inherit from father.address)
   (or son.greatgrandfather is set to inherit from father.father.father)
</pre>
-->

<h3>Saving to Disk</h3>

<p>
As you create new items and modify their values, the repository keeps track
of which ones need writing out to disk (these are referred to as "dirty").
The repository will write out any new or modified items to disk when you
call <span class='code'>commit( )</span>.  Exceptions will be raised if
anything fails such as failing schema validation, or what are called
"version conflicts" -- when another thread modified the same item you did.
</p>

<p>We've covered Chandler repository concepts, and now let's discuss
how Chandler functionality is added, using the parcel framework.  </p>

<p>
<br/>
</p>

<hr>

<p>
<br/>
</p>

<a name=parcels>
<h2>Parcel Loading Framework</h2>

<p> A "parcel" is the unit of extensibility in Chandler.  Parcels define
items that get loaded into the repository; these items can represent
schema, data, and behavior.  Upon startup, the parcel loading framework
scans the <span class='file'>parcels</span> directory for <span
class='file'>parcel.xml</span> files; XML elements within those files are
converted into repository items.  This section describes how to create the
parcel XML files.
</p>

<h2>Creating a Parcel</h2>
<h3>Parcel XML File</h3>

<p> To define a parcel, you first need to select where you want the parcel
items to live within the repository. The items for a parcel will get
created in the repository below <span class='path'>//parcels</span>
-- the exact path depends on where your parcel's directory is
relative to the <span class='file'>Chandler</span> directory.
If you're creating a parcel named "MyParcel", you could create a
<span class='file'>Chandler/parcels/MyParcel</span> directory; the
items from this parcel will get loaded into the repository at <span
class='path'>//parcels/MyParcel</span>.  </p>

<p>Once you have determined your parcel's directory, create a <span
class='file'>parcel.xml</span> file in there beginning with the
following:</p>

<pre class=xml>
&lt;?xml version="1.0" encoding="iso-8859-1"?&gt;

&lt;Parcel itemName="<span class='replace'>MyParcel</span>"
  xmlns="//Schema/Core"
  xmlns:<span class='replace'>myprefix</span>="<span class='replace'>//parcels/MyParcel</span>"&gt;
</pre>

<p><span class='replace'>MyParcel</span> will be used as the name
of the parcel item within the repository, and needs to match the
name of the directory the <span class='file'>parcel.xml</span>
file is in.  <span class='replace'>myprefix</span> defines a
namespace prefix which maps that string to a repository path.
For example, if you have defined a namespace prefix of <span
class='code'>xmlns:ex="//parcels/example"</span>, then you could later
refer to item <span class='path'>//parcels/example/item1</span> as
<span class='code'>ex:item1</span>.  If you will be referring to items
in other parcels, you need to add an xmlns: for each parcel.  </p>

<h3>Defining Schema</h3>

<p>
As described in the previous section, the Chandler data model supports schemas consisting of kind and attribute items.  Now we will step through how to define
those schema items in XML.
</p>

<h4>Defining Kinds</h4>

<p> To create a kind item in the repository, add a <span
class='code'>&lt;Kind&gt;</span> element to the XML (inside the <span
class='code'>&lt;Parcel&gt;</span> element): </p>

<pre class=xml>
  &lt;Kind itemName="<span class='replace'>MyKind</span>"&gt;
</pre>

<p>
<span class='replace'>MyKind</span> will be used as the name of the
kind item within the repository.  The name may not contain a slash (/) since
that character is used as the repository path delimiter.  By convention
the name should not contain any spaces. A more "people friendly" name accessible
from the item via <span class='code'>item.getItemName( )</span> can be
assigned by using <span class='tag'>&lt;displayName&gt;</span> (zero or one):
</p>

<pre class=xml>
    &lt;displayName&gt;<span class='replace'>Human readable name of kind</span>&lt;/displayName&gt;
</pre>

<p>
If this kind is to subclass from another kind (or kinds, since multiple
inheritence is supported), then specify each super-kind via
<span class='code'>&lt;superKinds&gt;</span> (zero or more):
</p>

<pre class=xml>
    &lt;superKinds itemref="<span class='replace'>nsprefix:kind</span>"/&gt;
</pre>

<p> <span class='replace'>nsprefix:kind</span> should be the repository
path of the super-kind.  Inherited attributes are resolved in a
left-to-right, depth-first search.</p>

<p>
To assign attributes to this kind -- in other words, what attributes will
be available to items based on this kind -- use
<code>&lt;attributes&gt;</code> tags (zero or more):
</p>

<pre class=xml>
    &lt;attributes itemref="<span class='replace'>nsprefix:attribute</span>"/&gt;
</pre>

<p> <span class='replace'>nsprefix:attribute</span> should be the
repository path of an attribute.  Finally, close the <span class='code'>&lt;Kind&gt;</span> element:</p>

<pre class=xml>
  &lt;/Kind&gt;
</pre>

<p>See the section below entitled "Items and Functionality" for a description
of how to associated a Python class with a kind.
</p>

<h4>Defining Attributes</h4>

<p>
To define an attribute in the repository, add an <code>&lt;Attribute&gt;</code> element:
</p>

<pre class=xml>
  &lt;Attribute itemName="<span class='replace'>MyAttribute</span>"&gt;
</pre>

<p>
<span class='replace'>MyAttribute</span> will be used as the name of the
attribute item within the repository.  The name may not contain a slash (/) since
that character is used as the repository path delimiter.  By convention
the name should not contain any spaces; a "human readable" name can be
assigned by using <code>&lt;displayName&gt;</code> (zero or one):
</p>

<pre class=xml>
    &lt;displayName&gt;<span class='replace'>Human readable name of attribute</span>&lt;/displayName&gt;
</pre>

<p>
If this attribute is to subclass from another attribute, then specify the super-attribute via <span class='code'>&lt;superAttribute&gt;</span> (zero or one):
</p>

<pre class=xml>
    &lt;superAttribute itemref="<span class='replace'>nsprefix:attribute</span>"/&gt;
</pre>

<p>Specify the type of the attribute (i.e., what kind of values may be
assigned to it), its cardinality ("single", "list", or "dict"), its
inverse attribute (if this is an item reference attribute), or any other
attribute aspects described in the repository introduction above:</p>

<pre class=xml>
    &lt;type itemref="<span class='replace'>nsprefix:kind</span>"/&gt;
    &lt;cardinality&gt;<span class='replace'>[single|list|dict]</span>&lt;/cardinality&gt;
    &lt;inverseAttribute itemref="<span class='replace'>nsprefix:attribute</span>"/&gt;
</pre>

<p> Finally, close the <span class='code'>&lt;Attribute&gt;</span> element:</p>

<pre class=xml>
  &lt;/Attribute&gt;
</pre>

<h3>Ending the XML File</h3>

<p>Once you have finished defining your kinds and attributes, end the
parcel XML by closing the <span class=code>&lt;Parcel&gt;</span> element.
</p>

<pre class=xml>
&lt;/Parcel&gt;
</pre>

<br/>

<h3>From XML to Repository Items</h3>

<h4>Processing the XML</h4>

<p>As the parcel loader parses the XML files, it creates an item
in the repository whenever it comes across an element with <span
class=code>itemName=</span> .  The kind used to create the item is
determined by the XML element, and the item's name is taken from the
value of <span class=code>itemName</span>.  When the loader sees an
XML element with <span class=code>itemref=</span>, an item reference
assignment is made to the item containing the element.  If the loader
comes across an element with neither <span class=code>itemName=</span>
or <span class=code>itemref=</span>, a literal attribute assignment
is made.  Nesting within the XML document is used to indicate
parent-child relationship between items.  For example, if <span
class='file'>parcels/example/parcel.xml</span> contained the following
XML...  </p>

<pre class=xml>
 1: &lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
 2:
 3: &lt;Parcel itemName="example"
 4:   xmlns="//Schema/Core"
 5:   xmlns:ex="//parcels/example"
 6:   xmlns:data="//parcels/example/data"&gt;
 7:
 8:   &lt;displayName&gt;My Example Parcel&lt;/displayName&gt;
 9:
10:   &lt;Kind itemName="ExampleKind"&gt;
11:       &lt;displayName&gt;My Example Kind&lt;/displayName&gt;
12:       &lt;attributes itemref="ex:linksTo"/&gt;
13:       &lt;attributes itemref="ex:linkedFrom"/&gt;
14:   &lt;/Kind&gt;
15:
16:   &lt;Attribute itemName="linksTo"&gt;
17:       &lt;displayName&gt;Links To&lt;/displayName&gt;
18:       &lt;cardinality&gt;list&lt;/cardinality&gt;
19:       &lt;type itemref="ex:ExampleKind"/&gt;
20:       &lt;inverseAttribute itemref="ex:linkedFrom"/&gt;
21:   &lt;/Attribute&gt;
22:
23:   &lt;Attribute itemName="linkedFrom"&gt;
24:       &lt;displayName&gt;Linked From&lt;/displayName&gt;
25:       &lt;cardinality&gt;list&lt;/cardinality&gt;
26:       &lt;type itemref="ex:ExampleKind"/&gt;
27:       &lt;inverseAttribute itemref="ex:linksTo"/&gt;
28:   &lt;/Attribute&gt;
29:
30: &lt;/Parcel&gt;
</pre>

<p>...here's how the parcel loader will process it:
<ul>

<li>line 3:  Seeing an element with <span
class='code'>itemName=</span>, the parcel loader will create an
item, <span class=path>//parcels/example</span>, of kind <span
class=path>//Schema/Core/Parcel</span>

<li>line 4:  Sets the default namespace to <span
class='path'>//Schema/Core</span> -- any further XML element names that
don't have a prefix will be relative to that repository path (i.e., Kind --&gt; <span class='path'>//Schema/Core/Kind</span>)

<li>lines 5 & 6:  Define two namespace mappings, 
ex --&gt; <span class='path'>//parcels/example</span>, and 
data --&gt; <span class='path'>//parcels/example/data</span>.  This means
that whenever one of these prefixes are used, the corresponding repository
path is substituted (i.e., ex:linksTo --&gt; <span class='path'>//parcels/example/linksTo</span>)

<li>line 8:  Seeing an element with no <span class='code'>itemName=</span>
or <span class='code'>itemref=</span>, the parcel loader will assign a
literal value, "My Example Parcel", to the displayName attribute of the
containing item (the example parcel)

<li>line 10:  Seeing an element with <span
class='code'>itemName=</span>, the parcel loader will create an item,
<span class=path>//parcels/example/ExampleKind</span>, of kind <span
class=path>//Schema/Core/Kind</span>; since this XML element is nested
inside the Parcel element, this new item will be a child of the parcel
item

<li>line 11:  Seeing an element with no <span class='code'>itemName=</span>
or <span class='code'>itemref=</span>, the parcel loader will assign a
literal value, "My Example Kind", to the displayName attribute of the
containing item (ExampleKind)

<li>line 12:  Seeing an element with <span class='code'>itemref=</span>,
the parcel loader will assign a reference (a pointer to <span
class='path'>//parcels/example/linksTo</span>) to the "attributes"
attribute of ExampleKind

<li>line 13:  Like line 12, a reference assignment is
made to EventKind.attributes -- adding a second item (<span
class='path'>//parcels/example/linkedFrom</span>) to that reference
collection

<li>line 16:  Seeing an element with <span
class='code'>itemName=</span>, the parcel loader will create an item,
<span class=path>//parcels/example/linksTo</span>, of kind <span
class=path>//Schema/Core/Attribute</span>; since this XML element is nested
inside the Parcel element, this new item will be a child of the parcel
item

<li>line 17:  Literal assignment -- linksTo.displayName = "Links To" --
this is the string that gets returned from <span class='code'>itemGetName( )</span>

<li>line 18:  Literal assignment -- linksTo.cardinality = "list"

<li>line 19:  Reference assignment -- linksTo.type points to the item
<span class='path'>//parcels/example/ExampleKind</span> -- the linksTo
attribute now expects to be assigned items of kind ExampleKind

<li>line 20:  Reference assignment -- linksTo.inverseAttribute points
to the item <span class='path'>//parcels/example/linkedFrom</span>; in
combination with line 27 this denotes the two attributes as inverses of
each other

</ul>
</p>


<h4>Defining Data</h4>

<p>In the 0.3 implementation, data items need to be defined in
a different parcel file than the schema items they are based upon.  One way
to accomplish this is to create a data subdirectory below your schema directory
and put another parcel.xml in the subdirectory.  Continuing our example
parcel, this would be
<span class='file'>Chandler/parcels/MyParcel/data/parcel.xml</span>.  Let's
define three instances of ExampleKind:
</p>

<pre class=xml>
 1: &lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
 2:
 3: &lt;Parcel itemName="data"
 4:   xmlns="//Schema/Core"
 5:   xmlns:ex="//parcels/example"
 6:   xmlns:data="//parcels/example/data"&gt;
 7:
 8:   &lt;displayName&gt;My Example Data&lt;/displayName&gt;
 9:
10:   &lt;ex:ExampleKind itemName="item1"&gt;
11:       &lt;displayName&gt;Example Item 1&lt;/displayName&gt;
12:       &lt;ex:linksTo itemref="data:item2"/&gt;
13:       &lt;ex:linksTo itemref="data:item3"/&gt;
14:   &lt;/ex:ExampleKind&gt;
15:
16:   &lt;ex:ExampleKind itemName="item2"&gt;
17:       &lt;displayName&gt;Example Item 2&lt;/displayName&gt;
18:   &lt;/ex:ExampleKind&gt;
19:
20:   &lt;ex:ExampleKind itemName="item3"&gt;
21:       &lt;displayName&gt;Example Item 3&lt;/displayName&gt;
22:   &lt;/ex:ExampleKind&gt;
23:
24: &lt;/Parcel&gt;
</pre>

<p>
<ul>

<li>line 3:  Creates a Parcel item, <span class='path'>//parcels/example/data</span>

<li>lines 4-6:  Define namespace prefixes

<li>line 8:  Assigns data.displayName = "My Example Data"

<li>line 10:  Creates an ExampleKind item, <span class='path'>//parcels/example/data/item1</span>

<li>line 11:  Assigns item1.displayName = "Example Item 1"

<li>lines 12 & 13:  Adds item2 and item3 to the item1.linksTo reference collection

<li>line 16:  Creates an ExampleKind item, <span class='path'>//parcels/example/data/item2</span>

<li>line 17:  Assigns item2.displayName = "Example Item 2"

<li>line 20:  Creates an ExampleKind item, <span class='path'>//parcels/example/data/item3</span>

<li>line 21:  Assigns item3.displayName = "Example Item 3"

</ul>
</p>

<br />

<h3>Items and Functionality</h3>

<p>Up until now we've discussed how to define schema and data items;
now we will add custom behavior to those items.  When defining a kind,
you can also specify a Python class that will be associated with that
kind -- items based on that kind will actually be instantiations of
the associated Python class.  This class needs to be a subclass of
repository.item.Item.Item -- either directly or indirectly.  The first
time those items are created, their <span class='code'>__init__( )</span>
method gets called (with name, parent, and kind as arguments).  Later on,
when an item gets loaded from the repository (for example, the next
time the application runs), the item's <span class='code'>onItemLoad(
)</span> method will get called.  Similarly, there is a <span
class='code'>onItemUnload( )</span> method that gets called whenever an
item gets unloaded from memory (when the item cache exceeds a certain size,
a transaction gets canceled, or some other thread has changed an item).
</p>

<p>Let's associate a custom Python class with ExampleKind:</p>

<pre class='codebox'>
import repository

class ExampleItem(repository.item.Item.Item):
    def __init__(self, name, parent, kind):
        repository.item.Item.Item.__init__(self, name, parent, kind)
        print "__init__ called"

    def onItemLoad(self):
        print "onItemLoad called"

    def onItemUnload(self):
        print "onItemUnload"
</pre>

<p>This class will live in <span class='file'>parcels/example/Example.py</span>. Next we'll modify our ExampleKind to associate it with ExampleItem:</p>

<pre class='xml'>
  &lt;Kind itemName="ExampleKind"&gt;
      &lt;displayName&gt;My Example Kind&lt;/displayName&gt;
      &lt;attributes itemref="ex:linksTo"/&gt;
      &lt;attributes itemref="ex:linkedFrom"/&gt;
      &lt;classes key="python"&gt;example.Example.ExampleItem&lt;/classes&gt;
  &lt;/Kind&gt;
</pre>

<p><span class='code'>classes</span> is a dictionary attribute used to
associate a kind with a class.  The first time our example parcel is
loaded the <span class='code'>__init__( )</span> method for items 1-3
will be called.  On subsequent runs the items will already exist in the
repository, and when retrieved, their <span class='code'>onItemLoad( )</span>
method will be called instead.</p>

<p>By default, items based on a kind with an associated class will be
created using that class.  However, you may override that by associating
a class to an individual item.  Just set the <span class='code'>&lt;itemClass&gt;</span> attribute on the item itself.
</p>

<p>If you are going to associate a parcel item with a class, be sure that 
class is a subclass of repository.parcel.Parcel.Parcel -- all parcel items
have their <span class='code'>startupParcel( )</span> method called during
each application start up.
</p>

<p>
<br/>
</p>

<a name=cpia>
<h3>CPIA View Items: Building Blocks for the Chandler UI</h3>

<p>The Chandler Presentation and Interaction Architecture (CPIA) defines
special items called "blocks" which are widgets that can be used to
create the user interface.   Blocks such as buttons, text boxes, and
list controls are combined into a "view".
Let's see how we can use the
parcel loading mechanism to build a simple view.  (CPIA is still very
much in flux -- please see the CPIA documentation and the Demo parcel
for further information)</p>

<p>We'll add another subdirectory, <span class='file'>views</span>, within
our <span class='file'>parcels/example</span> directory, and place the
following into its <span class='file'>parcel.xml</span>:</p>

<pre class='xml'>
  1: &lt;?xml version="1.0" encoding="iso-8859-1"?&gt;
  2: 
  3: &lt;Parcel itemName="views"
  4:         xmlns="//Schema/Core"
  5:         xmlns:blocks="//parcels/OSAF/framework/blocks"
  6:         xmlns:views="//parcels/example/views" &gt;
  7: 
  8:   &lt;blocks:BoxContainer itemName="ExampleView" itemClass="example.Example.ExampleView"&gt;
  9:     &lt;displayName&gt;My Example View&lt;/displayName&gt;
 10:     &lt;childrenBlocks itemref="views:ExampleButton"/&gt;
 11:     &lt;childrenBlocks itemref="views:ExampleText"/&gt;
 12:     &lt;blockEvents itemref="views:ExampleEvent"/&gt;
 13:     &lt;orientationEnum&gt;Horizontal&lt;/orientationEnum&gt;
 14:     &lt;open&gt;True&lt;/open&gt;
 15:     &lt;size&gt;0,0&lt;/size&gt;
 16:     &lt;minimumSize&gt;0,0&lt;/minimumSize&gt;
 17:     &lt;border&gt;0.0, 0.0, 0.0, 0.0&lt;/border&gt;
 18:     &lt;alignmentEnum&gt;grow&lt;/alignmentEnum&gt;
 19:     &lt;stretchFactor&gt;1.0&lt;/stretchFactor&gt;
 20:   &lt;/blocks:BoxContainer&gt;
 21: 
 22:   &lt;blocks:Button itemName="ExampleButton"&gt;
 23:     &lt;title&gt;Example Button&lt;/title&gt;
 24:     &lt;event itemref="views:ExampleEvent"/&gt;
 25:     &lt;buttonKind&gt;Text&lt;/buttonKind&gt;
 26:     &lt;open&gt;True&lt;/open&gt;
 27:     &lt;size&gt;160,40&lt;/size&gt;
 28:     &lt;minimumSize&gt;160,40&lt;/minimumSize&gt;
 29:     &lt;border&gt;0.0, 0.0, 0.0, 0.0&lt;/border&gt;
 30:     &lt;alignmentEnum&gt;alignCenter&lt;/alignmentEnum&gt;
 31:     &lt;stretchFactor&gt;0.0&lt;/stretchFactor&gt;
 32:   &lt;/blocks:Button&gt;
 33: 
 34:   &lt;blocks:EditText itemName="ExampleText"&gt;
 35:     &lt;textAlignmentEnum&gt;Left&lt;/textAlignmentEnum&gt;
 36:     &lt;lineStyleEnum&gt;MultiLine&lt;/lineStyleEnum&gt;
 37:     &lt;textStyleEnum&gt;PlainText&lt;/textStyleEnum&gt;
 38:     &lt;readOnly&gt;False&lt;/readOnly&gt;
 39:     &lt;characterStyle itemref="views:TextStyle"/&gt;
 40:     &lt;open&gt;True&lt;/open&gt;
 41:     &lt;size&gt;160,40&lt;/size&gt;
 42:     &lt;minimumSize&gt;160,40&lt;/minimumSize&gt;
 43:     &lt;border&gt;0.0, 0.0, 0.0, 0.0&lt;/border&gt;
 44:     &lt;alignmentEnum&gt;alignCenter&lt;/alignmentEnum&gt;
 45:     &lt;stretchFactor&gt;0.0&lt;/stretchFactor&gt;
 46:   &lt;/blocks:EditText&gt;
 47: 
 48:   &lt;blocks:BlockEvent itemName="ExampleEvent"&gt;
 49:     &lt;dispatchEnum&gt;SendToBlock&lt;/dispatchEnum&gt;
 50:     &lt;dispatchToBlock itemref="views:ExampleView"/&gt;
 51:     &lt;methodName&gt;OnExampleEvent&lt;/methodName&gt;
 52:   &lt;/blocks:BlockEvent&gt;
 53: 
 54:   &lt;blocks:CharacterStyle itemName="TextStyle"&gt;
 55:     &lt;fontFamily&gt;DefaultUIFont&lt;/fontFamily&gt;
 56:     &lt;fontSize&gt;10.0&lt;/fontSize&gt;
 57:     &lt;fontStyle&gt;&lt;/fontStyle&gt;
 58:     &lt;fontName&gt;&lt;/fontName&gt;
 59:   &lt;/blocks:CharacterStyle&gt;
 60: 
 61: &lt;/Parcel&gt;
</pre>

<p>The key points to mention are:
<ul>

<li>line 8: Defines a BoxContainer item, ExampleView, which is the outermost block for this view; other blocks will be placed inside this one
<li>lines 10 & 11: Specify which child blocks are to be placed inside
<li>line 12: Specifies which event this view is subscribing to
<li>line 22: Defines a push button
<li>line 24: Specifies that pushing the button triggers an ExampleEvent
<li>line 34: Defines a text box which will display a counter
<li>line 48: Defines a block event, "ExampleEvent"
<li>lines 49-50: Specify that the event is to be sent to the ExampleView item
<li>line 51: Specifies which method to call on each of this event's subscribers
</ul>

Since ExampleView is tied to a class, example.Example.ExampleView, we need
to add that class to our <span class='file'>parcels/example/Example.py</span>:
</p>

<pre class='codebox'>
from application import Globals
from OSAF.framework.blocks.ContainerBlocks import BoxContainer

class ExampleView(BoxContainer):

    def OnExampleEvent(self, notification):

        // Fetch item1 out of the repository and increment its counter
        item1 = Globals.repository.find('//parcels/example/data/item1')
        item1.counter = item1.counter + 1

        // Put the new counter value into the textbox
        textBox = Globals.repository.find('//parcels/example/views/ExampleText')
        wxTextBox = Globals.association[textBox.getUUID( )]
        wxTextBox.SetValue(str(item1.counter))
</pre>

<p>The <span class='code'>OnExampleEvent( )</span> method makes use of
item1.counter so we need to define that attribute in our schema file,
<span class='file'>parcels/example/parcel.xml</span>, and add the
attribute to ExampleKind:</p>

<pre class='xml'>
  &lt;Kind itemName="ExampleKind"&gt;
    [...]
    &lt;attributes itemref="ex:counter"&gt;
  &lt;/Kind&gt;

  &lt;Attribute itemName="counter"&gt;
    &lt;displayName&gt;Counter&lt;/displayName&gt;
    &lt;cardinality&gt;single&lt;/cardinality&gt;
    &lt;type itemref="Integer"/&gt;
  &lt;/Attribute&gt;
</pre>

<p>
Now that we've defined our view, we can add it to the sidebar so that we
can navigate to it.  Currently this is done by adding some items to 
<span class='file'>parcels/OSAF/views/main/parcel.xml</span>.  First we
add a namespace prefix to map to our example view parcel:</p>

<pre class='xml'>
&lt;core:Parcel itemName="main" [...] 
  xmlns:example="//parcels/example/views">
</pre>

<p>Next we add Node item specifying the string that will appear in the sidebar
and a reference to our view:</p>

<pre class='xml'>
&lt;Node itemName="ExampleView"&gt;
  &lt;displayName&gt;Example&lt;/displayName&gt;
  &lt;item itemref="example:ExampleView"/&gt;
&lt;/Node&gt;
</pre>

<p>Finally we add this Node item to the URLRoot item's "children" list:</p>

<pre class='xml'>
&lt;Node itemName="URLRoot"&gt;
  [...]
  &lt;item itemref="doc:ExampleView"/&gt;
&lt;/Node&gt;
</pre>

<p>When you run Chandler you will see "Example" in the sidebar;
clicking it should display our ExampleView with a button and text box.
Clicking the button will send an ExampleEvent to the view and call its
<span class='code'>OnExampleEvent( )</span> method, incrementing and
displaying the counter.  The value of the counter will persist across
application sessions.  </p>

<!--
<center>My notes, ignore anything past here:</center>

<ul>
<li>items get created out of from parcels
<li>__init__ of item happens
<li>when an item gets loaded from the repository, "itemload or something" gets called
<li>loadparcels() calls parcel.startupParcel()
<li>render - calls renderOneBlock() which instantiates the wx widgets; a bi-directional mapping between block item and widget is set up.
<li>wx events are captured by widgets; the event handlers Post the Chandler events through the notification manager; any subscribers within earshot are notified via the method name specified in the Event
<li>
</ul>


<hr>

<table border=1>

<tr> 
<td>Data Type</td>
<td>Parcel XML</td>
<td>Repository API Code</td>
</tr>

<tr> 
<td>Define a <em>Kind</em>, much like defining a class in the object oriented world</td>
<td><pre>
&lt;Kind itemName="<span class='replace'>PutNameOfKindHere</span>"&gt;
    &lt;displayName&gt;<span class='replace'>Put Name of Kind Here</span>&lt;/displayName&gt;
    &lt;superKinds itemref="<span class='replace'>nsprefix:kind</span>"&gt;
    &lt;attributes itemref="<span class='replace'>nsprefix:attribute</span>"&gt;
    &lt;classes key="python"&gt;<span class='replace'>python.path.to.class</span>&lt;/classes&gt;
&lt;/Kind&gt;
</pre></td>
<td><pre>
if className:
    cls = ClassLoader.loadClass(className)
    item = cls(name, parent, kind)
else:
    item = kind.newItem(name, parent)
</pre></td>
</tr>

<tr>
<td>Attribute</td>
<td>&lt;Attribute&gt;</td>
<td><pre>
ref = attributeKind.newItem(name, parent)
item.addValue('attributes', ref, alias=ref.getItemName())
</pre></td>
</tr>

</table>

<hr>
-->
<hr>
$Revision$
$Date$
$Author$
$Log$
Revision 1.2  2004/02/25 01:14:01  markie
Add keywords at end

</body>
</html>
