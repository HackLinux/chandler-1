<?xml version="1.0"?>

<DomainSchema itemName="core:CoreSchema" root="Core"
  xmlns="http://osafoundation.org/2003/08/CoreSchema"
  xmlns:core="http://osafoundation.org/2003/08/CoreSchema"
  xml:base="http://osafoundation.org/2003/08/CoreSchema">

<!-- the 'containmentPath' elements may be temporary -->
<!-- they might get replaced once we figure out parcel loading -->
<!-- right now, they're very handy for the xslt transform to our 'pack & item xml' formats -->
  <itemPathMapping prefix="core" path="//Schema/CoreSchema/"/>

  <displayName>Core</displayName>
  <version>0</version>
  <dependsOn itemref="core:CoreSchema"/>
  <description>
    Chandler stores Items.
    example: Chandler stores my calendar event "Lunch with Tug" 
     
    Each Item is an instance of some Kind.
    example: "Lunch with Tug" is an instance of an "Calendar Event" 
     
    Each Kind has a template of Attribute Definitions.
    example: An "Calendar Event" has a "start time", an "end time", a "headline", etc.
     
    Each Item instance has it's own list of Attribute Values.
    example: "Lunch with Tug" has a "start time", an "end time", a "headline", etc.
     
    An Item can have more Attribute Values than are in the template of Attribute Definitions for that Kind.
    example: "Lunch with Tug" has an "imaginary" attribute, even though "Calendar Event" does not have an "imaginary" attribute.
     
    Each attribute of an Item can have a Value.
    example: The "start time" of "Lunch with Tug" is "1:00pm".
     
    A value can be a literal, or a reference to another Item.
    example: The "start time" of "Lunch with Tug" is "1:00pm, 15 Mar 1992".
    example: The "owner" of "Lunch with Tug" is the user Tug, who created the Calendar Event.
     
    A Literal is an instance of some Type.
    example: "1:00pm, 15 Mar 1992" is a "datetime" 
     
    An Attribute Definition of one Kind can have a inverse Attribute Definition of another Kind
    example: The "reminder" attribute of "Calendar Event" is the inverse of the "event" attribute of "Reminder", so that each event knows whether it has a reminder, and each reminder knows which event to remind the user of.
  </description>

<!-- Global Attributes -->
  <Attribute itemName="core:displayName">
    <displayName>displayName</displayName>
    <description>Any sort of name for an item.</description>
    <cardinality>single</cardinality>
    <type itemref="core:String"/>
  </Attribute>

  <Attribute itemName="core:name">
    <displayName>name</displayName>
    <description>A human-readable name for an item.</description>
    <superAttribute itemref="core:displayName"/>
  </Attribute>

  <Attribute itemName="core:abbreviation">
    <displayName>abbreviation</displayName>
    <description>A human-readable abbreviation for a name.</description>
    <superAttribute itemref="core:displayName"/>
  </Attribute>

  <Attribute itemName="core:itemName">
    <displayName>identifier name</displayName>
    <description>A name for use in computer programs -- no spaces or special characters. Similar to (dublin core: creator).</description>
    <type itemref="core:Symbol"/>
    <superAttribute itemref="core:displayName"/>
    <hidden/>
  </Attribute>

  <Attribute itemName="core:annotation">
    <displayName>annotation</displayName>
    <description>Any sort of description or annotation for an item.</description>
    <cardinality>set</cardinality>
    <type itemref="core:String"/>
  </Attribute>

  <Attribute itemName="core:description">
    <displayName>description</displayName>
    <description>Any sort of comment or description to explain more about an item.</description>
    <cardinality>single</cardinality>
    <type itemref="core:String"/>
    <superAttribute itemref="core:annotation"/>
  </Attribute>

  <Attribute itemName="core:examples">
    <displayName>example</displayName>
    <description>An example of this item.</description>
    <superAttribute itemref="core:annotation"/>
  </Attribute>

  <Attribute itemName="core:issues">
    <displayName>issue</displayName>
    <description>Any open issue with this item.</description>
    <superAttribute itemref="core:annotation"/>
  </Attribute>

  <Attribute itemName="core:equivalent">
    <displayName>equivalent</displayName>
    <description>This item is conceptually equivalent to these others.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Item"/>
    <inverseAttribute itemref="core:equivalent"/>
    <relationshipType>equivalent</relationshipType>
  </Attribute>

  <Attribute itemName="core:hidden">
    <displayName>hidden</displayName>
    <description>Is this a 'hidden' system Type used for house-keeping, or is this a domain Type that an end-user would want to see?</description>
    <cardinality>single</cardinality>
    <type itemref="core:Boolean"/>
    <hidden/>
    <defaultValue>false</defaultValue>
  </Attribute>

  <Attribute itemName="core:type">
    <displayName>type</displayName>
    <description>What sorts of values can this field or attribute have?</description>
    <cardinality>set</cardinality>
    <type itemref="core:Taxon"/>
    <inverseAttribute itemref="core:usedAsTypeIn"/>
  </Attribute>

  <Attribute itemName="core:usedAsTypeIn">
    <displayName>used as type in</displayName>
    <description>What fields and attributes use this taxon as their type?</description>
    <cardinality>set</cardinality>
    <type itemref="core:Field"/>
    <type itemref="core:Attribute"/>
    <inverseAttribute itemref="core:type"/>
  </Attribute>

<!-- Item -->
  <Attribute itemName="core:uuid">
    <displayName>uuid</displayName>
    <description>The unique id of this item. Similar to (dublin core: creator).</description>
    <cardinality>single</cardinality>
    <required/>
    <type itemref="core:UUID"/>
    <hidden/>
  </Attribute>

  <Attribute itemName="core:instanceOf">
    <displayName>instance of</displayName>
    <description>The Kind that this item is an instance of.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Kind"/>
    <hidden/>
    <unidirectional/>
  </Attribute>

  <Attribute itemName="core:instanceOfPrimaryKind">
    <displayName>instance of primary kind</displayName>
    <description>The Kind that this item is an instance of. An item can be an instance of only one main Kind, although it can have additional 'instance of additional kinds'.</description>
    <cardinality>single</cardinality>
    <superAttribute itemref="core:instanceOf"/>
    <defaultValue>common:GenericItem</defaultValue>
  </Attribute>

  <Attribute itemName="core:instanceOfAdditionalKind">
    <displayName>instance of additional kinds</displayName>
    <description>Other Kinds that this item is also an instance of. An item can be an 'also instance of' more than one Kind. For example, a particular 'Email Message' could also be a 'Task'.</description>
    <superAttribute itemref="core:instanceOf"/>
  </Attribute>

  <Attribute itemName="core:createdBy">
    <displayName>created by</displayName>
    <description>Who made this item? Similar to (dublin core: creator).</description>
    <cardinality>single</cardinality>
    <required/>
    <type itemref="core:Operator"/>
    <hidden/>
    <inverseAttribute itemref="core:itemsCreated"/>
  </Attribute>

  <Attribute itemName="core:creationTime">
    <displayName>creation time</displayName>
    <description>When was this item created? Similar to (dublin core: created).</description>
    <cardinality>single</cardinality>
    <required/>
    <type itemref="core:RigidDatetime"/>
    <hidden/>
    <defaultValue>now</defaultValue>
  </Attribute>

  <Attribute itemName="core:lastModifiedTime">
    <displayName>last modified time</displayName>
    <description>When was this item last modified?</description>
    <cardinality>single</cardinality>
    <required/>
    <type itemref="core:RigidDatetime"/>
    <hidden/>
    <defaultValue>now</defaultValue>
  </Attribute>

  <Attribute itemName="core:deleted">
    <displayName>deleted</displayName>
    <description>Is this item now logically deleted?</description>
    <cardinality>single</cardinality>
    <required/>
    <type itemref="core:Boolean"/>
    <hidden/>
    <defaultValue>false</defaultValue>
  </Attribute>

  <Attribute itemName="core:repositoryContainmentParent">
    <displayName>parent</displayName>
    <description>The parent item in the repository containment hierarchy. If the parent value is null, then this is a root item.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Item"/>
    <hidden/>
    <inverseAttribute itemref="core:repositoryContainmentChildren"/>
    <relationshipType>parent</relationshipType>
  </Attribute>

  <Attribute itemName="core:repositoryContainmentChildren">
    <displayName>children</displayName>
    <description>The children items in the repository containment hierarchy.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Item"/>
    <hidden/>
    <inverseAttribute itemref="core:repositoryContainmentParent"/>
    <relationshipType>children</relationshipType>
  </Attribute>

  <Attribute itemName="core:repositoryContainmentPath">
    <displayName>path</displayName>
    <description>Path within the Chandler repository.</description>
    <derivation>Derived from 'parent' and 'identifier name'</derivation>
    <cardinality>single</cardinality>
    <type itemref="core:RepositoryContainmentPath"/>
    <hidden/>
  </Attribute>

  <Attribute itemName="core:proxyFor">
    <displayName>proxy for</displayName>
    <description>If this item is a copy of some record from another PIM, what's the address of the foreign record?</description>
    <cardinality>single</cardinality>
    <type itemref="core:ForeignItem"/>
    <hidden/>
    <inverseAttribute itemref="core:localCopy"/>
    <relationshipType>owns</relationshipType>
  </Attribute>

  <Attribute itemName="core:note">
    <displayName>note</displayName>
    <description>Any notes or annotations that people have made about this item.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Note"/>
    <inverseAttribute itemref="core:noteAppliesTo"/>
    <superAttribute itemref="core:annotation"/>
  </Attribute>

  <Attribute itemName="core:copyright">
    <displayName>copyright</displayName>
    <description>What is the copyright license for this item?</description>
    <cardinality>list</cardinality>
    <type itemref="core:Copyright"/>
    <inverseAttribute itemref="core:copyrightAppliesTo"/>
    <superAttribute itemref="core:annotation"/>
  </Attribute>

  <Attribute itemName="core:adHocAttributeList">
    <displayName>ad hoc attribute list</displayName>
    <description>What attributes have been added to this individual item?</description>
    <cardinality>set</cardinality>
    <type itemref="core:Attribute"/>
    <hidden/>
    <inverseAttribute itemref="core:usedAsAdHocAttributeInItems"/>
  </Attribute>

  <Attribute itemName="core:sameItemAs">
    <displayName>same item as</displayName>
    <description>If two items conceptually represent the same thing, we can use this attribute to make a note of that.  For example, in my address book I might accidentally create two different 'Contacts' for Amy Merkle.  I don't want to delete either of them, because other Items reference them, but I do want to Chandler to understand they're really should be the same Item.  See also the RDF/OWL notion of 'owl:sameIndividualAs'.</description>
    <inverseAttribute itemref="core:sameItemAs"/>
    <superAttribute itemref="core:equivalent"/>
  </Attribute>

  <Attribute itemName="core:suppliedIn">
    <displayName>supplied in</displayName>
    <description>The Domain Schema where this item comes from.</description>
    <cardinality>single</cardinality>
    <type itemref="core:DomainSchema"/>
    <hidden/>
    <inverseAttribute itemref="core:itemsSupplied"/>
  </Attribute>

  <Kind itemName="core:Item">
    <displayName>Item</displayName>
    <displayAttribute itemref="core:displayName"/>
    <attributes itemref="core:id"/>
    <attributes itemref="core:uuid"/>
    <attributes itemref="core:instanceOfPrimaryKind"/>
    <attributes itemref="core:instanceOfAdditionalKind"/>
    <attributes itemref="core:createdBy"/>
    <attributes itemref="core:creationTime"/>
    <attributes itemref="core:lastModifiedTime"/>
    <attributes itemref="core:deleted"/>
    <attributes itemref="core:repositoryContainmentParent"/>
    <attributes itemref="core:repositoryContainmentChildren"/>
    <attributes itemref="core:repositoryContainmentPath"/>
    <attributes itemref="core:proxyFor"/>
    <attributes itemref="core:note"/>
    <attributes itemref="core:copyright"/>
    <attributes itemref="core:adHocAttributeList"/>
    <attributes itemref="core:sameItemAs"/>
    <attributes itemref="core:suppliedIn"/>
  </Kind>

<!-- Domain Schema -->
  <Attribute itemName="core:dependsOn">
    <displayName>dependent on</displayName>
    <description>The other Domain Schemas that this one builds on top of.</description>
    <cardinality>set</cardinality>
    <type itemref="core:DomainSchema"/>
    <inverseAttribute itemref="core:isUsedBy"/>
    <relationshipType>parent</relationshipType>
  </Attribute>

  <Attribute itemName="core:isUsedBy">
    <displayName>is used by</displayName>
    <description>The other Domain Schemas that are built on top of this one.</description>
    <cardinality>set</cardinality>
    <type itemref="core:DomainSchema"/>
    <inverseAttribute itemref="core:dependsOn"/>
    <relationshipType>children</relationshipType>
  </Attribute>

  <Attribute itemName="core:version">
    <displayName>version</displayName>
    <description>Version info for this Domain Schema.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Version"/>
    <inverseAttribute itemref="core:currentItem"/>
    <superAttribute itemref="core:annotation"/>
  </Attribute>

  <Attribute itemName="core:schemaDefinitions">
    <displayName>definitions</displayName>
    <description>All the stuff defined by this schema: Types, Kinds, Attribute Definitions, Enums, etc.</description>
    <cardinality>set</cardinality>
    <type itemref="core:SchemaItem"/>
    <inverseAttribute itemref="core:definedInDomainSchema"/>
    <relationshipType>owns</relationshipType>
  </Attribute>

  <Attribute itemName="core:definedTypes">
    <displayName>defined Types</displayName>
    <description>All the Types defined by this schema</description>
    <type itemref="core:Type"/>
    <inverseAttribute itemref="core:typeDefinedInDomainSchema"/>
    <superAttribute itemref="core:schemaDefinitions"/>
  </Attribute>

  <Attribute itemName="core:definedKinds">
    <displayName>defined Kinds</displayName>
    <description>All the Kinds defined by this schema</description>
    <type itemref="core:Kind"/>
    <inverseAttribute itemref="core:kindDefinedInDomainSchema"/>
    <superAttribute itemref="core:schemaDefinitions"/>
  </Attribute>

  <Attribute itemName="core:definedAttributes">
    <displayName>defined Attribute Definitions</displayName>
    <description>All the Attribute Definitions defined by this schema</description>
    <type itemref="core:Attribute"/>
    <inverseAttribute itemref="core:attributeDefinedInDomainSchema"/>
    <superAttribute itemref="core:schemaDefinitions"/>
  </Attribute>

  <Attribute itemName="core:definedAliases">
    <displayName>defined Aliases</displayName>
    <description>All the Aliases defined by this schema</description>
    <type itemref="core:Alias"/>
    <inverseAttribute itemref="core:aliasDefinedInDomainSchema"/>
    <superAttribute itemref="core:schemaDefinitions"/>
  </Attribute>

  <Attribute itemName="core:itemsSupplied">
    <displayName>items supplied</displayName>
    <description>All the items included with the domain schema -- typically enum instances, but they could be anything.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Item"/>
    <inverseAttribute itemref="core:suppliedIn"/>
  </Attribute>

  <Kind itemName="core:DomainSchema">
    <displayName>Domain Schema</displayName>
    <displayAttribute itemref="core:displayName"/>
    <issues>We should arrange for each Domain Schema to have a namespace.  We might do that just by having an attribute on Domain Schema, or we might want to do something fancier using the Semantic Mapping feature.</issues>
    <superKinds itemref="core:Item"/>
    <attributes itemref="core:displayName"/>
    <attributes itemref="core:description"/>
    <attributes itemref="core:examples"/>
    <attributes itemref="core:issues"/>
    <attributes itemref="core:dependsOn"/>
    <attributes itemref="core:isUsedBy"/>
    <attributes itemref="core:version"/>
    <attributes itemref="core:definedTypes"/>
    <attributes itemref="core:definedKinds"/>
    <attributes itemref="core:definedAttributes"/>
    <attributes itemref="core:definedAliases"/>
    <attributes itemref="core:itemsSupplied"/>
  </Kind>

<!-- Schema Item -->
  <Attribute itemName="core:definedInDomainSchema">
    <displayName>defined in</displayName>
    <description>The Domain Schema where this item is defined.</description>
    <cardinality>single</cardinality>
    <type itemref="core:DomainSchema"/>
    <inverseAttribute itemref="core:schemaDefinitions"/>
    <relationshipType>ownedBy</relationshipType>
  </Attribute>

  <Kind itemName="core:SchemaItem">
    <displayName>Schema Item</displayName>
    <superKinds itemref="core:Item"/>
    <abstract/>
  </Kind>

<!-- Taxon -->
  <Attribute itemName="core:superTaxon">
    <displayName>super taxon</displayName>
    <description>The supertaxon(s) for this taxon.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Taxon"/>
    <inverseAttribute itemref="core:subTaxons"/>
    <relationshipType>parent</relationshipType>
  </Attribute>

  <Attribute itemName="core:subTaxons">
    <displayName>sub taxons</displayName>
    <description>The subtaxons of this taxon.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Taxon"/>
    <inverseAttribute itemref="core:superTaxon"/>
    <relationshipType>children</relationshipType>
  </Attribute>

  <Attribute itemName="core:usedInAlias">
    <displayName>used in alias</displayName>
    <description>What are all the various Aliases that include this taxon?</description>
    <cardinality>set</cardinality>
    <type itemref="core:Alias"/>
    <inverseAttribute itemref="core:aliasFor"/>
  </Attribute>

  <Kind itemName="core:Taxon">
    <displayName>Taxon</displayName>
    <description>
      Taxon can be a Kind, or a Type, or a Kind-of-Compound-Attribute. Taxon is an abstract superkind for these three other kinds.
    </description>
    <superKinds itemref="core:SchemaItem"/>
    <displayAttribute itemref="core:displayName"/>
    <abstract/>
    <attributes itemref="core:displayName"/>
    <attributes itemref="core:description"/>
    <attributes itemref="core:examples"/>
    <attributes itemref="core:issues"/>
    <attributes itemref="core:hidden"/>
    <attributes itemref="core:usedAsTypeIn"/>
    <attributes itemref="core:usedInAlias"/>
  </Kind>

<!-- Type -->
  <Attribute itemName="core:typeDefinedInDomainSchema">
    <displayName>defined in</displayName>
    <description>...add description here...</description>
    <superAttribute itemref="core:definedInDomainSchema"/>
    <inverseAttribute itemref="core:definedTypes"/>
  </Attribute>
  
  <Attribute itemName="core:superType">
    <displayName>super type</displayName>
    <description>The supertype for this type.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Type"/>
    <inverseAttribute itemref="core:subTypes"/>
    <superAttribute itemref="core:superTaxon"/>
    <defaultValue>core:Literal</defaultValue>
  </Attribute>

  <Attribute itemName="core:subTypes">
    <displayName>sub type</displayName>
    <description>The subtypes of this type.</description>
    <type itemref="core:Type"/>
    <inverseAttribute itemref="core:superType"/>
    <superAttribute itemref="core:subTaxons"/>
  </Attribute>

  <Attribute itemName="core:formats">
    <displayName>formats</displayName>
    <description>What display formats are available for this type?</description>
    <cardinality>set</cardinality>
    <type itemref="core:AttributeFormat"/>
    <inverseAttribute itemref="core:appliesToType"/>
  </Attribute>

  <Kind itemName="core:Type">
    <displayName>Type</displayName>
    <examples>'integer'</examples>
    <examples>'boolean'</examples>
    <examples>'string'</examples>
    <description>
      Items have attributes. Each attribute can have some associated type, and the attribute values for that attribute are restricted to being values of that type. An attribute's values can be completely unrestricted, or they can be restricted to some specific Kind, or some specific Type.
    </description>
    <issues>What is the list of supported types?</issues>
    <issues>Can a new Parcel create a new Type?</issues>
    <issues>What's actually involved in supporting a new Type? Beyond simply creating a new instance in the repository, what Chandler code has to be changed?</issues>
    <issues>What's the relationship between (a) a Type and (b) the formatting options for that Type? Should 'percentage' really be its own Type, or should it just be a way of formatting 'float'?</issues>
    <superKinds itemref="core:Taxon"/>
    <attributes itemref="core:typeDefinedInDomainSchema"/>
    <attributes itemref="core:superType"/>
    <attributes itemref="core:subTypes"/>
    <attributes itemref="core:formats"/>
  </Kind>

<!-- Compound-Type -->
  <Attribute itemName="core:field">
    <displayName>fields</displayName>
    <description>The fields in a compound type.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Field"/>
    <inverseAttribute itemref="core:owningType"/>
    <relationshipType>owns</relationshipType>
  </Attribute>

  <Kind itemName="core:CompoundType">
    <displayName>Compound-Type</displayName>
    <examples>'date' = 'year', 'month', 'day'</examples>
    <examples>'time' = 'hour', 'minute', 'second'</examples>
    <examples>'datetime' = 'date', 'time', 'timezone'</examples>
    <examples>'fraction' = 'numerator', 'denominator'</examples>
    <examples>'person name' = 'first name', 'middle name', 'last name', 'title', 'suffix'</examples>
    <examples>'quantity' = 'number', 'unit'</examples>
    <description>
      A Kind describes all the attributes that Items of that kind might typically have.  Similarly, a Compound-Type describes all the fields that compound literal might typically have.  Compound literals are similar to items, in that they both contain attributes.  But compound literals don't have UUIDs, so a compound literal can never be refered to except as a part of an item.  Compound literals are 'wholly owned' by the items that use them.
      For example, you might have a Person item that represents Abraham Lincoln. The item will have attributes, like 'date of birth', 'date of death', 'name', and 'nickname'. And the item has a UUID, and can be refered to by other items.  The 'nickname' attribute just holds a simple string literal, but the 'name' attribute holds a compound literal of the type 'person name', which has fields for 'first name', 'middle name', 'last name', etc.
    </description>
    <superKinds itemref="core:Type"/>
    <attributes itemref="core:field"/>
  </Kind>
  
<!-- Field -->
  <Attribute itemName="core:owningType">
    <displayName>owning type</displayName>
    <description>The compound type that this field is a part of.</description>
    <cardinality>single</cardinality>
    <type itemref="core:CompoundType"/>
    <inverseAttribute itemref="core:field"/>
    <relationshipType>ownedBy</relationshipType>
  </Attribute>

  <Kind itemName="core:Field">
    <displayName>Field</displayName>
    <superKinds itemref="core:SchemaItem"/>
    <displayAttribute itemref="core:displayName"/>
    <attributes itemref="core:displayName"/>
    <attributes itemref="core:description"/>
    <attributes itemref="core:examples"/>
    <attributes itemref="core:issues"/>
    <attributes itemref="core:owningType"/>
    <attributes itemref="core:type"/>
  </Kind>

<!-- Kind -->
  <Attribute itemName="core:abstract">
    <displayName>abstract</displayName>
    <description>TRUE if this is an abstract superkind and cannot be instantiated.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Boolean"/>
    <defaultValue>false</defaultValue>
  </Attribute>

  <Attribute itemName="core:attributes">
    <displayName>implied attributes</displayName>
    <description>A set of attributes typically found on items of this Kind.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Attribute"/>
    <inverseAttribute itemref="core:usedInKind"/>
  </Attribute>

  <Attribute itemName="core:displayAttribute">
    <displayName>display attribute</displayName>
    <description>For items of this kind, what attribute should we look in to find a human readable name for this item?  For example, in an Email Message item we might use the 'subject' attribute, and in a Contact item we might use the 'person name' attribute.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Attribute"/>
    <type itemref="core:AttributeChain"/>
    <inverseAttribute itemref="core:usedAsDisplayAttribute"/>
  </Attribute>

  <Attribute itemName="core:equivalentKinds">
    <displayName>equivalent kinds</displayName>
    <description>Similar to the RDF/OWL property 'owl:equivalentClass'.</description>
    <type itemref="core:Kind"/>
    <inverseAttribute itemref="core:equivalentKinds"/>
    <superAttribute itemref="core:equivalent"/>
  </Attribute>

  <Attribute itemName="core:kindDefinedInDomainSchema">
    <displayName>defined in</displayName>
    <description>...add description here...</description>
    <superAttribute itemref="core:definedInDomainSchema"/>
    <inverseAttribute itemref="core:definedKinds"/>
  </Attribute>

  <Attribute itemName="core:superKinds">
    <displayName>super kind</displayName>
    <description>The superkinds for this kind.</description>
    <type itemref="core:Kind"/>
    <inverseAttribute itemref="core:subKinds"/>
    <superAttribute itemref="core:superTaxon"/>
    <defaultValue>core:Item</defaultValue>
  </Attribute>

  <Attribute itemName="core:subKinds">
    <displayName>sub kinds</displayName>
    <description>The subkinds of this kind.</description>
    <type itemref="core:Kind"/>
    <inverseAttribute itemref="core:superKinds"/>
    <superAttribute itemref="core:subTaxons"/>
  </Attribute>

  <Kind itemName="core:Kind">
    <displayName>Kind</displayName>
    <examples>Calendar Event</examples>
    <examples>Contact</examples>
    <examples>Sailing Ship</examples>
    <examples>Homework Assignment</examples>
    <description>
      A Kind represents a 'type', or 'class', or 'category' of items.
      A Kind can represent: new user-defined Kind ('Book', 'Sailing Ship', 'Course', 'Homework Assignment', 'Grade', etc.).
      A Kind can represent: a Kind from a standard Parcel ('Calendar Event', 'Task', 'Contact', etc.)
      A Kind can represent: a basic Kind of system Item ('Kind', 'Item', 'Change')
    </description>
    <superKinds itemref="core:Taxon"/>
    <attributes itemref="core:abstract"/>
    <attributes itemref="core:attributes"/>
    <attributes itemref="core:displayAttribute"/>
    <attributes itemref="core:equivalentKind"/>
    <attributes itemref="core:kindDefinedInDomainSchema"/>
    <attributes itemref="core:superKinds"/>
    <attributes itemref="core:subKinds"/>
  </Kind>

<!-- Alias -->
  <Attribute itemName="core:aliasFor">
    <displayName>alias for</displayName>
    <description>What are all the various Types or Kinds that this is an alias for?</description>
    <cardinality>set</cardinality>
    <required/>
    <type itemref="core:Taxon"/>
    <inverseAttribute itemref="core:usedInAlias"/>
  </Attribute>

  <Attribute itemName="core:aliasDefinedInDomainSchema">
    <displayName>defined in</displayName>
    <description>...add description here...</description>
    <superAttribute itemref="core:definedInDomainSchema"/>
    <inverseAttribute itemref="core:definedAliases"/>
  </Attribute>

  <Kind itemName="core:Alias">
    <displayName>Taxon Alias</displayName>
    <examples>'String' = 'ASCII String' | 'Unicode String' | 'Polyglot String'</examples>
    <examples>'Datetime' = 'Rigid Datetime' | 'Flexible Datetime'</examples>
    <examples>'Anything' = 'Item' | 'Literal'</examples>
    <description>
      Let's say 'String' is a type that's an alias for either 'Unicode String' or 'Polyglot String'. Then, if an Attribute Definition is supposed to be of type 'String', that means the attribute value can be a Unicode String or a Polyglot String
    </description>
    <superKinds itemref="core:Taxon"/>
    <attributes itemref="core:aliasFor"/>
    <attributes itemref="core:aliasDefinedInDomainSchema"/>
  </Kind>

<!-- Attribute Definition -->
  <Attribute itemName="core:superAttribute">
    <displayName>super attribute</displayName>
    <description>What attribute is this a sub-attribute of?</description>
    <cardinality>single</cardinality>
    <type itemref="core:Attribute"/>
    <inverseAttribute itemref="core:subAttributes"/>
    <relationshipType>parent</relationshipType>
  </Attribute>

  <Attribute itemName="core:subAttributes">
    <displayName>sub attributes</displayName>
    <description>What attributes have this one as their super attribute?</description>
    <cardinality>set</cardinality>
    <type itemref="core:Attribute"/>
    <inverseAttribute itemref="core:superAttribute"/>
    <relationshipType>children</relationshipType>
  </Attribute>

  <Attribute itemName="core:cardinality">
    <displayName>cardinality</displayName>
    <description>How many values can this attribute have?</description>
    <cardinality>single</cardinality>
    <type itemref="core:CardinalityEnum"/>
    <unidirectional/>
    <defaultValue>core:single</defaultValue>
  </Attribute>

  <Attribute itemName="core:defaultValue">
    <displayName>default value</displayName>
    <description>What default value is 'copied' into new instances?</description>
    <cardinality>single</cardinality>
    <type itemref="core:Anything"/>
  </Attribute>

  <Attribute itemName="core:defaultFormat">
    <displayName>default format</displayName>
    <description>How should this attribute be displayed in a table?</description>
    <cardinality>single</cardinality>
    <type itemref="core:AttributeFormat"/>
    <inverseAttribute itemref="core:usedAsDefaultFormat"/>
  </Attribute>

  <Attribute itemName="core:restrictions">
    <displayName>restrictions</displayName>
    <description>What restrictions are there on the values we expect to have for attribute?</description>
    <cardinality>set</cardinality>
    <type itemref="core:AttributeRestriction"/>
    <inverseAttribute itemref="core:appliesToAttribute"/>
    <relationshipType>owns</relationshipType>
  </Attribute>

  <Attribute itemName="core:equivalentAttributes">
    <displayName>equivalent attributes</displayName>
    <description>Similar to the RDF/OWL property 'owl:equivalentProperty'.</description>
    <type itemref="core:Attribute"/>
    <inverseAttribute itemref="core:equivalentAttributes"/>
    <superAttribute itemref="core:equivalent"/>
  </Attribute>

  <Attribute itemName="core:required">
    <displayName>required</displayName>
    <description>TRUE if this attribute is not allowed to have a NULL value.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Boolean"/>
    <defaultValue>false</defaultValue>
  </Attribute>

  <Attribute itemName="core:derivation">
    <displayName>derivation rule</displayName>
    <description>How should Chandler automatically calculate the value of this attribute?</description>
    <cardinality>single</cardinality>
    <type itemref="core:DerivationRule"/>
    <inverseAttribute itemref="core:derivedAttribute"/>
    <relationshipType>owns</relationshipType>
  </Attribute>
  
  <Attribute itemName="core:inverseAttribute">
    <displayName>inverse attribute</displayName>
    <description>On the item that this attribute points to, what attribute points to this item?  Similar to the RDF/OWL property 'owl:inverseOf'.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Attribute"/>
    <inverseAttribute itemref="core:inverseAttribute"/>
  </Attribute>

  <Attribute itemName="core:unidirectional">
    <displayName>unidirectional</displayName>
    <description>TRUE if the value of this attribute points to another item, but that item has no attribute that points back to this item.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Boolean"/>
    <defaultValue>false</defaultValue>
  </Attribute>

  <Attribute itemName="core:relationshipType">
    <displayName>relationship type</displayName>
    <description>What sort of relationship does this item have to the item pointed to by this attribute?</description>
    <cardinality>single</cardinality>
    <type itemref="core:RelationshipTypeEnum"/>
    <unidirectional/>
    <defaultValue>core:peer</defaultValue>
  </Attribute>

  <Attribute itemName="core:attributeDefinedInDomainSchema">
    <displayName>defined in</displayName>
    <description>...add description here...</description>
    <superAttribute itemref="core:definedInDomainSchema"/>
    <inverseAttribute itemref="core:definedAttributes"/>
  </Attribute>
  
  <Attribute itemName="core:usedInKind">
    <displayName>usedInKind</displayName>
    <description>Which kinds use this attribute as one of their implied attributes, typically found on items of that Kind?</description>
    <cardinality>set</cardinality>
    <type itemref="core:Kind"/>
    <inverseAttribute itemref="core:attributes"/>
  </Attribute>

  <Attribute itemName="core:usedAsDisplayAttribute">
    <displayName>used as display attribute</displayName>
    <description>Which kinds use this attribute as the source for a human readable display name for items?  For example, in an Email Message item we might use the 'subject' attribute, and in a Contact item we might use the 'person name' attribute.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Kind"/>
    <inverseAttribute itemref="core:displayAttribute"/>
  </Attribute>

  <Attribute itemName="core:usedAsAdHocAttributeInItems">
    <displayName>ad hoc attribute in items</displayName>
    <description>What items have include this as an ad hoc attribute?</description>
    <cardinality>set</cardinality>
    <type itemref="core:Item"/>
    <hidden/>
    <inverseAttribute itemref="core:adHocAttributeList"/>
  </Attribute>

  <Attribute itemName="core:transitive">
    <displayName>transitive</displayName>
    <description>Is this a transitive relationship?  A relationship 'foo' is transitive when ((A.foo = B, and B.foo = C) means that (A.foo = C)). For example, the 'subclass' relationship is transitive.  If A is a subclass of B, and B is a subclass of C, then A is a subclass C.  Similar to the RDF/OWL property 'owl:TransitiveProperty'.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Boolean"/>
    <derivation>Derived from core:relationshipType.</derivation>
  </Attribute>

  <Attribute itemName="core:symmetric">
    <displayName>symmetric</displayName>
    <description>Is this a symmetric relationship?  A relationship 'foo' is symmetric when ((A.foo = B) means that (B.foo = A)). For example, the 'spouse' relationship is symmetric.  If A is the spouse of B, then B is the spouse of A.  Similar to the RDF/OWL property 'owl:SymmetricProperty'.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Boolean"/>
    <derivation>Derived from core:relationshipType.</derivation>
  </Attribute>

  <Attribute itemName="core:deletePolicy">
    <displayName>delete policy</displayName>
    <description>If A has a reference to B, and vice-versa, what do we do when A is deleted?  Do we delete B also, or do we just remove B's reference to A, or do we delete B only if nobody else now references B?</description>
    <cardinality>single</cardinality>
    <type itemref="core:DeletePolicyEnum"/>
    <derivation>Derived from core:relationshipType.</derivation>
  </Attribute>

  <Attribute itemName="core:copyPolicy">
    <displayName>copy policy</displayName>
    <description>If A has a reference to B, and vice-versa, what do we do when A is copied?  Do we copy B also (deep copy), or do we just set the new copy of A to point to the old version of B (shallow copy)?</description>
    <cardinality>single</cardinality>
    <type itemref="core:CopyPolicyEnum"/>
    <derivation>Derived from core:relationshipType.</derivation>
  </Attribute>


  <Kind itemName="core:Attribute">
    <displayName>Attribute Definition</displayName>
    <examples>('name', text string)</examples>
    <examples>('height', integer)</examples>
    <examples>('author', Person)</examples>
    <description>
      Kinds have Attribute Definitions. Each Attribute Definition can have some associated type, and the Attribute Values for that Attribute Definition are restricted to being values of that type.  An attribute's values can be completely unrestricted, or they can be restricted to some specific Kind, or some specific Type.  Attribute Definitions can also have default values, and default formats, derivation rules, etc.
      Some Attribute Definitions are global, and other Attribute Definitions are associated with a single Kind.  Also, some Attribute Definitions are associated with a single instance of an Item, rather than for a Kind.
    </description>
    <issues>It's not clear how best to associate an Attribute Definition with an Item or a Kind.  For example, let's say we have a Kind called "Book", and an Item called "The Cat in the Hat".  We want "Book" to have an Attribute Definition called 'author', and "The Cat in the Hat" has an 'author' of "Dr. Suess".  We also want to have a global Attribute Definition 'author', which is a sub-attribute of the dublin core attribute 'creator'.  The global 'author' can be shared, so that it is used for Books, Movies, Articles, and a wide variety of other Kinds.  The global 'author' has a shared semantic meaning, and it has a few shared properties, like the 'name': 'author'.  But in the context of our "Book", we want to say more about the 'author'.  Let's say that in the context of "Book", 'author' should be required, should have a cardinality of 'one' (not 'many'), and should have values of type "Person".  How do we associate that extra information with the notion of the 'author' Attribute Definition as it appears in the "Book" Kind?  One option is to have a global "Attribute Definition" for 'author' (which just has a name and maybe one or two other properties), and then have a separate "Attribute Binding" that associates 'author' and "Book" (which has a cardinality, type, etc.).  An second option is to use only "Attribute Definitions", not "Attribute Bindings", but to allow the "Book" to have its own "Attribute Definition" for 'author', which would have a pointer up to the global shared 'author', and which would provide additional properties (like cardinality) that we would interpret as _refining_ or _overriding_ or _extending_ the properties of the global 'author' Attribute Definition.  In this scenario, some Attribute Definitions would be associated with a particular Kind, while others would be associated with some more globally scoped item, like a Domain Schema.  To further complicate matters, individual items can have ad hoc attributes.  For example, a user could edit "The Cat in the Hat" and add an attribute 'foo' with a value of 'foobar', even though in general a "Book" doesn't have a 'foo' attribute.  So that means some Attribute Definitions can be associated with individual items.  We would probably like to make the assertion that each Attribute Definition should be defined in exactly one place, where that place is either an individual Item (like "The Cat in the Hat"), a Kind (like "Book"), or a Domain Schema (for global attributes). And each of those 3 places would have a different inverse attribute.  Since Domain Schemas and Kinds are both Items, you'd think we could just generally say that this thing is 'defined in' an Item.  But that won't work, because when this thing is 'defined in' a Kind, we need to explicitly use a different inverse attribute from the one used for Item, so that we can tell whether this thing is serving as an Attribute Definition for (a) the Item-ness of the Kind Item, or (b) the Kind-ness of the Kind Item.  Yikes!  Here's a quick example, to make that last point more concrete.  Let's say I have some Kind, like 'Book', and I just want to jot a little note on it using an ad hoc attribute called 'my little note about the Book Kind'.  If 'my little note about the Book Kind' is an Attribute Definition that's 'defined in' the Kind 'Book', how do we avoid misinterpreting it to mean that all books have a 'my little note about the Book Kind' attribute.</issues>
    <issues>Some Attributes have values that are literals, while others have values that are references to other Items. Right now, we instead just merge the 'Reference Definition' attributes up into 'Attribute Definition', which is a little sloppy.</issues>
    <superKinds itemref="core:SchemaItem"/>
    <displayAttribute itemref="core:displayName"/>
    <attributes itemref="core:displayName"/>
    <attributes itemref="core:description"/>
    <attributes itemref="core:examples"/>
    <attributes itemref="core:issues"/>
    <attributes itemref="core:hidden"/>
    <attributes itemref="core:superAttribute"/>
    <attributes itemref="core:subAttributes"/>
    <attributes itemref="core:type"/>
    <attributes itemref="core:cardinality"/>
    <attributes itemref="core:default"/>
    <attributes itemref="core:defaultFormat"/>
    <attributes itemref="core:restrictions"/>
    <attributes itemref="core:equivalentAttributes"/>
    <attributes itemref="core:required"/>
    <attributes itemref="core:derivation"/>
    <attributes itemref="core:inverseAttribute"/>
    <attributes itemref="core:unidirectional"/>
    <attributes itemref="core:relationshipType"/>
    <attributes itemref="core:attributeDefinedInDomainSchema"/>
    <attributes itemref="core:usedInKind"/>
    <attributes itemref="core:usedAsDisplayAttribute"/>
    <attributes itemref="core:usedAsAdHocAttributeInItems"/>
    <attributes itemref="core:transitive"/>
    <attributes itemref="core:symmetric"/>
    <attributes itemref="core:deletePolicy"/>
    <attributes itemref="core:copyPolicy"/>
  </Kind>

<!-- Attribute Chain -->
  <Attribute itemName="core:attributeChain">
    <displayName>attribute chain</displayName>
    <description>An ordered list of the attributes that we should follow to hop from one item to the next.</description>
    <cardinality>list</cardinality>
    <type itemref="core:Attribute"/>
  </Attribute>

  <Kind itemName="core:AttributeChain">
    <displayName>Attribute Chain</displayName>
    <examples>employee.department.departmentManager.lastName</examples>
    <superKinds itemref="core:Item"/>
    <attributes itemref="core:attributeChain"/>
  </Kind>

<!-- Enum Kind -->
  <Attribute itemName="core:appearsInEnumeration">
    <displayName>appears in enumeration</displayName>
    <description>This item is one of the possible values in these enumerations.</description>
    <cardinality>set</cardinality>
    <type itemref="core:EnumKind"/>
    <inverseAttribute itemref="core:element"/>
  </Attribute>

  <Attribute itemName="core:element">
    <displayName>elements</displayName>
    <description>An ordered list of the values the possible values for this enum, each of which is an item.</description>
    <cardinality>list</cardinality>
    <type itemref="core:Item"/>
    <inverseAttribute itemref="core:appearsInEnumeration"/>
  </Attribute>

  <Kind itemName="core:EnumKind">
    <displayName>Enumeration Kind</displayName>
    <examples>In a bug tracking system, you might have a 'bug priority' enum, with values of 'high', 'medium', and 'low'</examples>
    <issues>If we set things up this way, how do we do strong typing?  If 'bug priority' is just an Item, not a Kind, then on the Kind for 'Bug', how do we have an Attribute Definition that's strongly typed to point to a 'bug priority' value?  Maybe we need to make Enum be a Subkind of Kind instead of a Subkind of Item, and then have 'Bug Priority' be a SubKind of Enum with an attribute that points to its list of instances (the 'extension' of the Kind).</issues>
    <superKinds itemref="core:Kind"/>
    <abstract/>
    <attributes itemref="core:element"/>
  </Kind>

<!-- Cardinality Enum -->
  <EnumKind itemName="core:CardinalityEnum">
    <displayName>Cardinality Enum</displayName>
    <element>core:single</element>
    <element>core:set</element>
    <element>core:list</element>
  </EnumKind>

  <Item itemName="core:single"/>
  <Item itemName="core:set"/>
  <Item itemName="core:list"/>

<!-- Delete Policy Enum -->
  <EnumKind itemName="core:DeletePolicyEnum">
    <displayName>Delete Policy Enum</displayName>
    <element>core:cascadeDelete</element>
    <element>core:strongReference</element>
    <element>core:weakReference</element>
  </EnumKind>

  <Item itemName="core:cascadeDelete"/>
  <Item itemName="core:strongReference"/>
  <Item itemName="core:weakReference"/>

<!-- Copy Policy Enum -->
  <EnumKind itemName="core:CopyPolicyEnum">
    <displayName>Copy Policy Enum</displayName>
    <element>core:deepCopy</element>
    <element>core:shallowCopy</element>
    <element>core:superShallowCopy</element>
  </EnumKind>

  <Item itemName="core:deepCopy"/>
  <Item itemName="core:shallowCopy"/>
  <Item itemName="core:superShallowCopy"/>

<!-- Relationship Type Enum -->
  <EnumKind itemName="core:RelationshipTypeEnum">
    <displayName>Relationship Type Enum</displayName>
    <element>core:peer</element>
    <element>core:parent</element>
    <element>core:children</element>
    <element>core:owns</element>
    <element>core:ownedBy</element>
    <element>core:equivalent</element>
  </EnumKind>

  <Item itemName="core:peer"/>
  <Item itemName="core:parent"/>
  <Item itemName="core:children"/>
  <Item itemName="core:owns"/>
  <Item itemName="core:ownedBy"/>
  <Item itemName="core:equivalent"/>

<!-- Attribute Format -->
  <Attribute itemName="core:appliesToType">
    <displayName>applies to type</displayName>
    <description>Which type is this a display format for?</description>
    <cardinality>single</cardinality>
    <type itemref="core:Type"/>
    <inverseAttribute itemref="core:formats"/>
  </Attribute>

  <Attribute itemName="core:formatString">
    <displayName>format string</displayName>
    <examples>DD MMM YYYY</examples>
    <examples>MM/DD/YY HH:MM</examples>
    <examples>NN%</examples>
    <examples>$ N,NNN.NN</examples>
    <cardinality>single</cardinality>
    <type itemref="core:String"/>
  </Attribute>

  <Attribute itemName="core:formatFields">
    <displayName>format string</displayName>
    <description>A list of the attribute fields used in the format string.</description>
    <cardinality>list</cardinality>
    <type itemref="core:Field"/>
  </Attribute>

  <Attribute itemName="core:usedAsDefaultFormat">
    <displayName>used as default format</displayName>
    <description>What attributes use this as their default format?</description>
    <cardinality>set</cardinality>
    <type itemref="core:Attribute"/>
    <inverseAttribute itemref="core:defaultFormat"/>
  </Attribute>

  <Kind itemName="core:AttributeFormat">
    <displayName>Attribute Format</displayName>
    <examples>DD MMM YYYY</examples>
    <examples>MM/DD/YY HH:MM</examples>
    <examples>NN%</examples>
    <examples>$ N,NNN.NN</examples>
    <issues>What's the relationship, if any, between this AttributeFormat and the CPIA notion of a display phrase?</issues>
    <superKinds itemref="core:Item"/>
    <displayAttribute itemref="core:formatString"/>
    <attributes itemref="core:appliesToType"/>
    <attributes itemref="core:formatString"/>
    <attributes itemref="core:formatFields"/>
    <attributes itemref="core:usedAsDefaultFormat"/>
  </Kind>

<!-- Attribute Restriction -->
  <Attribute itemName="core:appliesToAttribute">
    <displayName>applies to</displayName>
    <description>Which attribute is this a restriction on?</description>
    <cardinality>single</cardinality>
    <required/>
    <type itemref="core:Attribute"/>
    <inverseAttribute itemref="core:restrictions"/>
    <relationshipType>ownedBy</relationshipType>
  </Attribute>

  <Attribute itemName="core:restrictionInfo">
    <displayName>restriction</displayName>
    <description>What is the actual restriction? </description>
    <issues>(@@@ -- If we want to support restrictions, this needs to be not a 'Simple String', but rather some more complicated machine-readable specification of the restriction.</issues>
    <cardinality>single</cardinality>
    <required/>
    <type itemref="core:SimpleString"/>
  </Attribute>

  <Kind itemName="core:AttributeRestriction">
    <displayName>Attribute Restriction</displayName>
    <examples>'rainfall' should be a non-negative number</examples>
    <examples>'age' should be over 21</examples>
    <examples>'start-time' should come before 'end-time'</examples>
    <examples>my 'mother' should have a 'birth-date' prior to my 'birth-date'</examples>
    <examples>my 'mother' should not be the 'daughter' of my 'son'</examples>
    <description>
      See the wiki page for DataModelIssues#Restrictions_on_Attributes.
    </description>
    <issues>How do we actually represent the restriction info?</issues>
    <issues>Should we change the name to be 'Expectation' instead of 'Restriction'?</issues>
    <superKinds itemref="core:Item"/>
    <displayAttribute itemref="core:restrictionInfo"/>
    <attributes itemref="core:appliesToAttribute"/>
    <attributes itemref="core:restrictionInfo"/>
  </Kind>

<!-- Derivation Rule -->
  <Attribute itemName="core:derivedAttribute">
    <displayName>derived attribute</displayName>
    <description>Which attribute does this derivation rule apply to?</description>
    <cardinality>single</cardinality>
    <type itemref="core:DerivationRule"/>
    <inverseAttribute itemref="core:derivation"/>
    <relationshipType>ownedBy</relationshipType>
  </Attribute>
  
  <Attribute itemName="core:formula">
    <displayName>formula</displayName>
    <description>What is the actual derivation rule?</description>
    <issues>(@@@ -- not clear how to represent this.</issues>
    <cardinality>single</cardinality>
    <required/>
    <type itemref="core:SimpleString"/>
  </Attribute>

  <Kind itemName="auto:DerivationRule">
    <displayName>Derivation Rule</displayName>
    <superKinds itemref="core:Item"/>
    <displayAttribute itemref="core:formula"/>
    <attributes itemref="core:derivedAttribute"/>
    <attributes itemref="core:formula"/>
  </Kind>

<!-- Note -->
  <Attribute itemName="core:noteAppliesTo">
    <displayName>item</displayName>
    <description>The item or items being annotated</description>
    <cardinality>set</cardinality>
    <type itemref="core:Item"/>
    <inverseAttribute itemref="core:note"/>
  </Attribute>

  <Attribute itemName="core:content">
    <displayName>content</displayName>
    <description>The annotation itself</description>
    <cardinality>single</cardinality>
    <type itemref="core:PolyglotText"/>
  </Attribute>

  <Kind itemName="core:Note">
    <displayName>Note</displayName>
    <examples>'They called on Tuesday and said it would be ready by Friday at noon.'</examples>
    <examples>'This is probably trash now -- feel free to delete it.'</examples>
    <description>
      An Note represents a note that a user adds to an e-mail message or to any other item. An annotation might also represent an actual editing change to the original message itself. See EditingReceivedEmail. See MessageAnnotation.
    </description>
    <issues>Are Notes always associated with exactly 1 Item?</issues>
    <issues>Can a selection of 5 Items be annotated with 1 Note?</issues>
    <issues>Can a particular attribute of an Item be the subject of a note? (example: I select the 'population' field of the 'Canada' Item, and I add the annotation: 'The U.N. says this is now over 32 million')</issues>
    <issues>Is a note just a bunch of text?</issues>
    <issues>Can an note represent an actual edit to the original Item? (example: I edit the body of an e-mail message and change a misspelling.)</issues>
    <superKinds itemref="core:Item"/>
    <displayAttribute itemref="core:content"/>
    <attributes itemref="core:noteAppliesTo"/>
    <attributes itemref="core:content"/>
  </Kind>

<!-- Copyright -->
  <Attribute itemName="core:holder">
    <displayName>holder</displayName>
    <description>The copyright holder or holders.</description>
    <cardinality>list</cardinality>
    <type itemref="core:PersonOrOganization"/>
    <type itemref="core:String"/>
    <deletePolicy>strong reference</deletePolicy>
  </Attribute>

  <Attribute itemName="core:copyrightDate">
    <displayName>date</displayName>
    <description>The copyright date.  Typically a year, or list of years, or a range of years.</description>
    <cardinality>list</cardinality>
    <type itemref="core:Date"/>
    <type itemref="core:String"/>
  </Attribute>

  <Attribute itemName="core:license">
    <displayName>license</displayName>
    <description>The copyright license (e.g. 'All rights reserved').</description>
    <cardinality>list</cardinality>
    <type itemref="core:PolyglotText"/>
  </Attribute>

  <Attribute itemName="core:copyrightAppliesTo">
    <displayName>copyright applies to</displayName>
    <description>What items is this the copyright for?</description>
    <cardinality>set</cardinality>
    <type itemref="core:Item"/>
    <inverseAttribute itemref="core:copyright"/>
  </Attribute>

  <Kind itemName="core:Copyright">
    <displayName>Copyright</displayName>
    <examples>'Copyright (c) 2003 by Farmer Jones, all rights reserved.'</examples>
    <examples>The creativecommons.org 'Public Domain Dedication'.</examples>
    <description>
      A Copyright represents a copyright statement and license terms.
    </description>
    <superKinds itemref="core:Item"/>
    <displayAttribute itemref="core:license"/>
    <attributes itemref="core:holder"/>
    <attributes itemref="core:copyrightDate"/>
    <attributes itemref="core:license"/>
    <attributes itemref="core:copyrightAppliesTo"/>
  </Kind>

<!-- Language -->
  <Attribute itemName="core:iso6391Code">
    <displayName>ISO 639-1 Code</displayName>
    <description>example: 'en' -- ISO 639-1 Codes</description>
    <cardinality>single</cardinality>
    <type itemref="core:SimpleString"/>
    <superAttribute itemref="core:abbreviation"/>
  </Attribute>

  <Attribute itemName="core:iso6392Code">
    <displayName>ISO 639-2 Code</displayName>
    <description>ISO 639-2 Codes</description>
    <cardinality>single</cardinality>
    <type itemref="core:SimpleString"/>
    <superAttribute itemref="core:abbreviation"/>
  </Attribute>

  <Attribute itemName="core:country">
    <displayName>country</displayName>
    <description>A country, in the sense of the ISO 3166 notion of country</description>
    <cardinality>single</cardinality>
    <type itemref="core:Country"/>
    <inverseAttribute itemref="core:langauges"/>
  </Attribute>

  <Attribute itemName="core:rfc1766Code">
    <displayName>RFC 1766 Code</displayName>
    <derivation>derived from iso6391Code, and country.rfc3166Code</derivation>
    <cardinality>single</cardinality>
    <type itemref="core:SimpleString"/>
    <superAttribute itemref="core:abbreviation"/>
  </Attribute>

  <Attribute itemName="core:rfc3066Code">
    <displayName>RFC 3066 Code</displayName>
    <derivation>derived from iso6391Code, iso6392Code, and country.iso3166Code</derivation>
    <cardinality>single</cardinality>
    <type itemref="core:SimpleString"/>
    <superAttribute itemref="core:abbreviation"/>
  </Attribute>

  <Kind itemName="core:Language">
    <displayName>Language</displayName>
    <examples>English</examples>
    <examples>French</examples>
    <examples>Spanish</examples>
    <examples>Japanese</examples>
    <description>
      A Language Item represents the language that a text string is in. For example, the string 'Calendar' would be associated with the language 'English', whereas the string 'Veranstaltungskalender' would be associated with the language 'German'.
    </description>
    <superKinds itemref="core:Item"/>
    <displayAttribute itemref="core:displayName"/>
    <attributes itemref="core:displayName"/>
    <attributes itemref="core:iso6391Code"/>
    <attributes itemref="core:iso6392Code"/>
    <attributes itemref="core:country"/>
    <attributes itemref="core:rfc1766Code"/>
    <attributes itemref="core:rfc3066Code"/>
  </Kind>

<!-- Country -->
  <Attribute itemName="core:rfc3166Code">
    <displayName>RFC 3166 Code</displayName>
    <description>a two letter country code</description>
    <cardinality>single</cardinality>
    <type itemref="core:SimpleString"/>
    <superAttribute itemref="core:abbreviation"/>
  </Attribute>

  <Attribute itemName="core:langauges">
    <displayName>langauges</displayName>
    <description>The languages that are used in this country.</description>
    <cardinality>set</cardinality>
    <type itemref="core:Language"/>
    <inverseAttribute itemref="core:country"/>
  </Attribute>

  <Kind itemName="core:Country">
    <displayName>Country</displayName>
    <examples>France</examples>
    <examples>Japan</examples>
    <description>A Country represents one of the nations in the world.</description>
    <superKinds itemref="core:Item"/>
    <displayAttribute itemref="core:displayName"/>
    <attributes itemref="core:displayName"/>
    <attributes itemref="core:rfc3166Code"/>
    <attributes itemref="core:langauges"/>
  </Kind>

<!-- Operator -->
  <Attribute itemName="core:itemsCreated">
    <displayName>items created</displayName>
    <description>What items has this operator created?</description>
    <cardinality>set</cardinality>
    <type itemref="core:Item"/>
    <hidden/>
    <inverseAttribute itemref="core:createdBy"/>
  </Attribute>

  <Kind itemName="core:Operator">
    <displayName>Operator</displayName>
    <examples>Vanessa Kline</examples>
    <examples>Kevin Rulwa's e-mail agent</examples>
    <description>
      Someone or something that can create and edit items.
    </description>
    <superKinds itemref="core:Item"/>
    <abstract/>
    <attributes itemref="core:description"/>
    <attributes itemref="core:itemsCreated"/>
  </Kind>

<!-- VersionInfo -->
  <Attribute itemName="core:versionInfo">
    <displayName>version info</displayName>
    <description>A simple version number, or some simple version string, or a version info item, or a URL that points to a page with version info.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Anything"/>
  </Attribute>

  <Attribute itemName="core:currentItem">
    <displayName>current item</displayName>
    <description>The item that this is the version info for.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Item"/>
    <inverseAttribute itemref="core:version"/>
  </Attribute>

  <Kind itemName="core:Version">
    <displayName>Version</displayName>
    <description>
      A minimal placeholder for storing version info.  Sub-kinds of this kind can add more sophisiticated representations for doing high-tech versioning and keeping track of version changes.
    </description>
    <superKinds itemref="core:Item"/>
    <displayAttribute itemref="core:versionInfo"/>
    <attributes itemref="core:versionInfo"/>
    <attributes itemref="core:currentItem"/>
  </Kind>

<!-- Foreign Item -->
  <Attribute itemName="core:sourceItem">
    <displayName>source item</displayName>
    <description>Type is probably a 'string' or a 'URL' or some kind of item with more detailed info. In any case, it's whatever info we need to keep track of in order to find the original information from the foreign data source.</description>
    <cardinality>single</cardinality>
    <type itemref="core:String"/>
    <type itemref="core:URL"/>
    <type itemref="core:Anything"/>
  </Attribute>

  <Attribute itemName="core:rawSnapshot">
    <displayName>raw snapshot</displayName>
    <description>This attribute is jus a place for keeping a copy of the raw information, just the way it was when we first read it from the foreign data source.</description>
    <cardinality>single</cardinality>
    <type itemref="core:String"/>
    <type itemref="core:Blob"/>
    <type itemref="core:Anything"/>
  </Attribute>

   <Attribute itemName="core:localCopy">
    <displayName>local copy</displayName>
    <description>The Chanlder Item that's a copy of the information from this foreign source.</description>
    <cardinality>single</cardinality>
    <type itemref="core:Item"/>
    <inverseAttribute itemref="core:proxyFor"/>
    <relationshipType>ownedBy</relationshipType>
  </Attribute>

  <Kind itemName="core:ForeignItem">
    <displayName>Foreign Item</displayName>
    <description>...add description here...</description>
    <superKinds itemref="core:Item"/>
    <displayAttribute itemref="core:sourceItem"/>
    <attributes itemref="core:sourceItem"/>
    <attributes itemref="core:rawSnapshot"/>
    <attributes itemref="core:localCopy"/>
  </Kind>

<!-- String -->
  <Alias itemName="core:String">
    <displayName>String</displayName>
    <description>
      If an attribute is of type 'String', the values are allowed to be any sort of string type: an 'Simple String' (like a 'Unicode String'), or a 'Compound String' (like a 'Polyglot String').
    </description>
    <aliasFor itemref="core:SimpleString"/>
    <aliasFor itemref="core:CompoundString"/>
  </Alias>

<!-- Datetime -->
  <Alias itemName="core:Datetime">
    <displayName>Datetime</displayName>
    <description>
      If an attribute is of type 'Datetime', the values are allowed to be any sort of datetime type: an 'Rigid Datetime' or a 'Flexible Datetime'.
    </description>
    <aliasFor itemref="core:RigidDatetime"/>
    <aliasFor itemref="core:FlexibleDatetime"/>
  </Alias>

<!-- Anything -->
  <Alias itemName="core:Anything">
    <displayName>Anything</displayName>
    <description>
      If an attribute is of type 'Anything', the values are allowed to be any type: any 'Item' or any 'Literal'.
    </description>
    <aliasFor itemref="core:Item"/>
    <aliasFor itemref="core:Literal"/>
  </Alias>

<!-- Literal -->
  <Type itemName="core:Literal">
    <displayName>Literal</displayName>
    <examples>25</examples>
    <examples>0.75</examples>
    <examples>TRUE</examples>
    <examples>'this is a simple string'</examples>
    <description>
      The abstract root for all the literal types such as Integer, Float, Boolean, and String.
    </description>
    <abstract/>
  </Type>

<!-- Number -->
  <Type itemName="core:Number">
    <displayName>Number</displayName>
    <examples>25</examples>
    <examples>0.75</examples>
    <superType itemref="core:Literal"/>
    <abstract/>
  </Type>

<!-- Integer -->
  <Type itemName="core:Integer">
    <displayName>Integer</displayName>
    <examples>25</examples>
    <examples>75</examples>
    <superType itemref="core:Number"/>
  </Type>

<!-- Float -->
  <Type itemName="core:Float">
    <displayName>Float</displayName>
    <examples>2.5</examples>
    <examples>0.75</examples>
    <superType itemref="core:Number"/>
  </Type>

<!-- Boolean -->
  <Type itemName="core:Boolean">
    <displayName>Boolean</displayName>
    <examples>TRUE</examples>
    <examples>FALSE</examples>
    <superType itemref="core:Literal"/>
  </Type>

<!-- Blob -->
  <Type itemName="core:Blob">
    <displayName>Blob</displayName>
    <description>
      A sequence of bytes.  A blob of binary data, like you would find inside a gif or an mp3.
    </description>
    <superType itemref="core:Literal"/>
  </Type>

<!-- Simple String -->
  <Type itemName="core:SimpleString">
    <displayName>Simple String</displayName>
    <examples>'this is a simple string'</examples>
    <examples>'the future of ideas'</examples>
    <description>
      A simple text string.  Strings can include words that have links -- links to Chandler items or traditional web browser URL links.
    </description>
    <superType itemref="core:Literal"/>
    <abstract/>
  </Type>

<!-- Symbol -->
  <Type itemName="core:Symbol">
    <displayName>Symbol</displayName>
    <description>
      A short ASCII string with no spaces or special characters.  Something suitable for using as a variable name in Python or Java.
    </description>
    <superType itemref="core:SimpleString"/>
  </Type>

<!-- ASCII String -->
  <Type itemName="core:ASCIIString">
    <displayName>ASCII String</displayName>
    <description>
      Any ASCII string.  Just plain text, with no special markup that Chandler knows anything about.
    </description>
    <superType itemref="core:SimpleString"/>
  </Type>

<!-- Unicode String -->
  <Type itemName="core:UnicodeString">
    <displayName>Unicode String</displayName>
    <description>
      Any Unicode string.  Just plain text, with no special markup that Chandler knows anything about.
    </description>
    <superType itemref="core:SimpleString"/>
  </Type>

<!-- Rich Text String -->
  <Type itemName="core:RichTextString">
    <displayName>Rich Text String</displayName>
    <description>
      A string where some of the words might be bold, or italic, or underlined, or drawn in red.  The string is stored with some kind of graphical markup info that Chandler knows how to parse when it displays the string.  For markup, we could use RTF, or some subset of HTML, or something else entirely.
    </description>
    <superType itemref="core:SimpleString"/>
  </Type>

<!-- RepositoryContainmentPath -->
  <Type itemName="core:RepositoryContainmentPath">
    <displayName>Path</displayName>
    <examples>//home/kitchen/fridge/ketchup</examples>
    <description>
      Every item can be found in the repository through its path, a / separated concatenation of the item's name and its parent ancestry. A path to an item can be expressed relative to the repository in which case it begins with //. A path to an item can be expressed relative to the item's root in which case it begins with /. Or it can be expressed relative to an item in which case it begins with a name.
    </description>
    <superType itemref="core:Literal"/>
  </Type>

<!-- UUID -->
  <Type itemName="core:UUID">
    <displayName>UUID</displayName>
    <examples>e2d03cb4-9d58-11d7-d179-000393db837c</examples>
    <description>
      Every item can be found in the repository through its UUID, a Universally Unique IDentifier. The UUID is a 128-bit number implemented following the UUID IETF specification draft.
    </description>
    <superType itemref="core:Literal"/>
  </Type>

<!-- Any URI -->
  <Type itemName="core:AnyURI">
    <displayName>Any URI</displayName>
    <examples>http://www.osafoundation.org/</examples>
    <examples>rap://esu.edu/~pat/contacts/clive</examples>
    <description>
      A conventional URL or URI.
    </description>
    <superType itemref="core:Literal"/>
  </Type>

<!-- Rigid Datetime -->
  <Type itemName="core:RigidDatetime">
    <displayName>Rigid Datetime</displayName>
    <examples>2003/08/11 3:34:45</examples>
    <description>
      A datetime that's required to have valid values for all fields: YYYY/MM/DD hh:mm:ss. A rigid datetime could be stored as an integer like 'number of seconds since 1970', whereas a Flexible Datetime can not, because it may not have some fields: year or day or time of day.
    </description>
    <superType itemref="core:Literal"/>
    <field>
      <displayName>year</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>month</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>day</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>hour</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>minute</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>second</displayName>
      <type itemref="core:Integer"/>
    </field>
    <field>
      <displayName>timezone</displayName>
      <type itemref="core:Timezone"/>
    </field>
  </Type>

<!-- Timezone -->
  <Attribute itemName="core:majorCities">
    <displayName>major cities</displayName>
    <description>example: 'Los Angeles' -- a few major cities in each timezone</description>
    <cardinality>list</cardinality>
    <type itemref="core:String"/>
  </Attribute>

  <Kind itemName="core:Timezone">
    <displayName>Timezone</displayName>
    <examples>('PST', 'Pacific Standard Time', -8:00)</examples>
    <examples>('PDT', 'Pacific Daylight Time', -7:00)</examples>
    <examples>('PT', 'Pacific Time', (transition rules), PST, PDT)</examples>
    <description>
      There's set of about 70 time zones in the world.
    </description>
    <superKinds itemref="core:Item"/>
    <displayAttribute itemref="core:displayName"/>
    <attributes itemref="core:displayName"/>
    <attributes itemref="core:abbreviation"/>
    <attributes itemref="core:majorCities"/>
  </Kind>

<!-- Fixed Timezone -->
  <Attribute itemName="core:utcOffset">
    <displayName>UTC Offset</displayName>
    <description>example: -7:00</description>
    <cardinality>single</cardinality>
    <type itemref="core:Duration"/>
  </Attribute>

  <Attribute itemName="core:summerTimezoneFor">
    <displayName>summer timezone for</displayName>
    <description>example: the 'PDT' fixed timezone is the summer timezone for the 'Pacific Time' DST timezone</description>
    <cardinality>set</cardinality>
    <type itemref="core:DaylightSavingTimezone"/>
    <inverseAttribute itemref="core:summerTimezone"/>
  </Attribute>

  <Attribute itemName="core:winterTimezoneFor">
    <displayName>winter timezone for</displayName>
    <description>example: the 'PST' fixed timezone is the summer timezone for the 'Pacific Time' DST timezone</description>
    <cardinality>set</cardinality>
    <type itemref="core:DaylightSavingTimezone"/>
    <inverseAttribute itemref="core:winterTimezone"/>
  </Attribute>

  <Kind itemName="core:FixedTimezone">
    <displayName>Fixed Timezone</displayName>
    <examples>('PST', 'Pacific Standard Time', -8:00)</examples>
    <examples>('PDT', 'Pacific Daylight Time', -7:00)</examples>
    <description>
      A fixed timezone is one that has a constant UTC Offset all year round, rather than changing to observe Daylight Saving Time.
    </description>
    <superKinds itemref="core:Timezone"/>
    <attributes itemref="core:utcOffset"/>
    <attributes itemref="core:summerTimezoneFor"/>
    <attributes itemref="core:winterTimezoneFor"/>
  </Kind>

  <core:FixedTimezone itemName="core:PST_Timezone">
    <core:displayName>Pacific Standard Time</core:displayName>
    <core:abbreviation>PST</core:abbreviation>
    <core:utcOffset>-8:00</core:utcOffset>
  </core:FixedTimezone>

  <core:FixedTimezone itemName="core:PDT_Timezone">
    <core:displayName>Pacific Daylight Time</core:displayName>
    <core:abbreviation>PDT</core:abbreviation>
    <core:utcOffset>-7:00</core:utcOffset>
  </core:FixedTimezone>
  
<!-- Daylight Saving Timezone -->
  <Attribute itemName="core:summerTimezone">
    <displayName>summer timezone</displayName>
    <description>example: PDT</description>
    <cardinality>single</cardinality>
    <type itemref="core:FixedTimezone"/>
    <inverseAttribute itemref="core:summerTimezoneFor"/>
  </Attribute>

  <Attribute itemName="core:winterTimezone">
    <displayName>winter timezone</displayName>
    <description>example: PST</description>
    <cardinality>single</cardinality>
    <type itemref="core:FixedTimezone"/>
    <inverseAttribute itemref="core:winterTimezoneFor"/>
  </Attribute>

  <Attribute itemName="core:transitionRule">
    <displayName>transition rule</displayName>
    <description>@@@ -- some representation that specifies when the transitions happen, like a table of transition times, or some kind of recurrence rule</description>
    <cardinality>single</cardinality>
    <type itemref="core:String"/>
  </Attribute>

  <Kind itemName="core:DaylightSavingTimezone">
    <displayName>Daylight Saving Timezone</displayName>
    <examples>('PT', 'Pacific Time', (transition rules), PST, PDT)</examples>
    <description>
      A daylight saving timezone is one that changes twice a year, to observe daylight saving time during the summer.
    </description>
    <superKinds itemref="core:Timezone"/>
    <attributes itemref="core:summerTimezone"/>
    <attributes itemref="core:winterTimezone"/>
    <attributes itemref="core:transitionRule"/>
  </Kind>

  <core:DaylightSavingTimezone itemName="core:PT_Timezone">
    <core:displayName>Pacific Time</core:displayName>
    <core:abbreviation>PT</core:abbreviation>
    <core:summerTimezone itemref="core:PDT_Timezone"/>
    <core:winterTimezone itemref="core:PST_Timezone"/>
  </core:DaylightSavingTimezone>

<!-- Date -->
  <Attribute itemName="core:year">
    <displayName>year</displayName>
    <description>e.g. 1992</description>
    <cardinality>single</cardinality>
    <type itemref="core:Integer"/>
  </Attribute>

  <Attribute itemName="core:month">
    <displayName>month</displayName>
    <description>range between 1 and 12</description>
    <cardinality>single</cardinality>
    <type itemref="core:Integer"/>
  </Attribute>

  <Attribute itemName="core:day">
    <displayName>day</displayName>
    <description>range between 1 and 31</description>
    <cardinality>single</cardinality>
    <type itemref="core:Integer"/>
  </Attribute>

  <Attribute itemName="core:dayOfTheWeek">
    <displayName>day of the week</displayName>
    <derivation>derived from (day/month/year)</derivation>
    <cardinality>single</cardinality>
    <type itemref="core:String"/>
  </Attribute>

  <Kind itemName="core:Date">
    <displayName>Date</displayName>
    <description>
      'date' = 'year', 'month', 'day'
    </description>
    <superKinds itemref="core:Item"/>
    <attributes itemref="core:year"/>
    <attributes itemref="core:month"/>
    <attributes itemref="core:day"/>
    <attributes itemref="core:dayOfTheWeek"/>
  </Kind>

<!-- Time -->
  <Attribute itemName="core:hour">
    <displayName>hours</displayName>
    <description>...add description here...</description>
    <cardinality>single</cardinality>
    <type itemref="core:Number"/>
  </Attribute>

  <Attribute itemName="core:minute">
    <displayName>minutes</displayName>
    <description>...add description here...</description>
    <cardinality>single</cardinality>
    <type itemref="core:Number"/>
  </Attribute>

  <Attribute itemName="core:second">
    <displayName>seconds</displayName>
    <description>...add description here...</description>
    <cardinality>single</cardinality>
    <type itemref="core:Number"/>
  </Attribute>

  <Attribute itemName="core:timezone">
    <displayName>timezone</displayName>
    <description>...add description here...</description>
    <cardinality>single</cardinality>
    <type itemref="core:Timezone"/>
  </Attribute>

  <Kind itemName="core:Time">
    <displayName>Time</displayName>
    <description>
      'time' = 'hour', 'minute', 'second'
    </description>
    <superKinds itemref="core:Item"/>
    <attributes itemref="core:hour"/>
    <attributes itemref="core:minute"/>
    <attributes itemref="core:second"/>
    <attributes itemref="core:timezone"/>
  </Kind>

<!-- Flexible Datetime -->
  <Kind itemName="core:FlexibleDatetime">
    <displayName>Flexible Datetime</displayName>
    <description>
      'datetime' = 'date', 'time', 'timezone'
    </description>
    <superKinds itemref="core:Item"/>
    <attributes itemref="core:year"/>
    <attributes itemref="core:month"/>
    <attributes itemref="core:day"/>
    <attributes itemref="core:dayOfTheWeek"/>
    <attributes itemref="core:hour"/>
    <attributes itemref="core:minute"/>
    <attributes itemref="core:second"/>
    <attributes itemref="core:timezone"/>
  </Kind>

<!-- Duration -->
  <Attribute itemName="core:years">
    <displayName>years</displayName>
    <description>...add description here...</description>
    <cardinality>single</cardinality>
    <type itemref="core:Number"/>
  </Attribute>

  <Attribute itemName="core:months">
    <displayName>months</displayName>
    <description>...add description here...</description>
    <cardinality>single</cardinality>
    <type itemref="core:Number"/>
  </Attribute>

  <Attribute itemName="core:days">
    <displayName>days</displayName>
    <description>...add description here...</description>
    <cardinality>single</cardinality>
    <type itemref="core:Number"/>
  </Attribute>

  <Attribute itemName="core:hours">
    <displayName>hours</displayName>
    <description>...add description here...</description>
    <cardinality>single</cardinality>
    <type itemref="core:Number"/>
  </Attribute>

  <Attribute itemName="core:minutes">
    <displayName>minutes</displayName>
    <description>...add description here...</description>
    <cardinality>single</cardinality>
    <type itemref="core:Number"/>
  </Attribute>

  <Attribute itemName="core:seconds">
    <displayName>seconds</displayName>
    <description>...add description here...</description>
    <cardinality>single</cardinality>
    <type itemref="core:Number"/>
  </Attribute>

  <Kind itemName="core:Duration">
    <displayName>Duration</displayName>
    <description>
      'duration' = 'years', 'months', 'days', 'hours', 'minutes', 'seconds'
    </description>
    <superKinds itemref="core:Item"/>
    <attributes itemref="core:years"/>
    <attributes itemref="core:months"/>
    <attributes itemref="core:days"/>
    <attributes itemref="core:hours"/>
    <attributes itemref="core:minutes"/>
    <attributes itemref="core:seconds"/>
  </Kind>

<!-- Compound String -->
  <Kind itemName="core:CompoundString">
    <displayName>Compound String</displayName>
    <superKinds itemref="core:Item"/>
    <abstract/>
  </Kind>

<!-- String with References -->
  <Attribute itemName="core:stringWithReferenceTags">
    <displayName>string with reference tags</displayName>
    <description>The text string itself, including some special tags to mark the substrings that have references.</description>
    <cardinality>single</cardinality>
    <type itemref="core:SimpleString"/>
  </Attribute>

  <Attribute itemName="core:references">
    <displayName>references</displayName>
    <description>A list of the items that the string has links to.</description>
    <cardinality>list</cardinality>
    <type itemref="core:Item"/>
  </Attribute>

  <Kind itemName="core:StringWithReferences">
    <displayName>String with References</displayName>
    <examples>'Lunch with [_1]Sally[/_1] and [_2]Jim[/_2]'</examples>
    <description>
      A string that includes 'references' to other Chandler Items.
    </description>
    <issues>The interaction between this 'String with References' and 'Polyglot String' could be complicated. Maybe we just shouldn't bother supporting Polyglot Strings with References.</issues>
    <issues>What's the relationship between this 'String with References' and the notion of a 'display phrase'?</issues>
    <superKinds itemref="core:CompoundString"/>
    <attributes itemref="core:stringWithReferenceTags"/>
    <attributes itemref="core:references"/>
  </Kind>

<!-- String with Language Tag -->
  <Attribute itemName="core:language">
    <displayName>language</displayName>
    <description>example: 'English'</description>
    <cardinality>single</cardinality>
    <required/>
    <type itemref="core:Language"/>
    <unidirectional/>
  </Attribute>

  <Attribute itemName="core:value">
    <displayName>value</displayName>
    <description>example: 'Hello World'</description>
    <cardinality>single</cardinality>
    <required/>
    <type itemref="core:SimpleString"/>
  </Attribute>

  <Kind itemName="core:StringwithLanguageTag">
    <displayName>String with Language Tag</displayName>
    <examples>(en, 'Hello World')</examples>
    <examples>(de, 'Guten Tag Welt')</examples>
    <description>
      A 'String with Langague Tag' represents a single string literal, associated with the language that it's in.
    </description>
    <superKinds itemref="core:CompoundString"/>
    <attributes itemref="core:language"/>
    <attributes itemref="core:value"/>
  </Kind>

<!-- Polyglot String -->
  <Attribute itemName="core:strings">
    <displayName>strings</displayName>
    <description>this is like a Python dictionary, with string translations keyed by language</description>
    <cardinality>set</cardinality>
    <type itemref="core:StringwithLanguageTag"/>
  </Attribute>

  <Kind itemName="core:PolyglotString">
    <displayName>Polyglot String</displayName>
    <examples>'Hello World' / 'Guten Tag Welt' / ...</examples>
    <description>
      A Polyglot String represents a collection of related strings, with one string for each Language that the string has been translated into.
    </description>
    <superKinds itemref="core:CompoundString"/>
    <attributes itemref="core:strings"/>
  </Kind>

<!-- Polyglot Text -->
  <Alias itemName="core:PolyglotText">
    <displayName>Polyglot Text</displayName>
    <examples>'Congress shall make no law respecting an establishment of religion, or prohibiting the free exercise thereof; or abridging the freedom of speech, or of the press; or the right of the people peaceably to assemble, and to petition the government for a redress of grievances.'</examples>
    <description>
      A Text item represents a block of text.  Text items can have tabs, carriage returns, etc.  Optionally, Text items can also have rich text formatting, including bold, italics, etc.
    </description>
    <issues>@@@ -- we need to address the whole issue of the 'string vs. text' distinction.</issues>
    <aliasFor itemref="core:PolyglotString"/>
  </Alias>

<!-- Person Or Oganization -->
  <Kind itemName="core:PersonOrOganization">
    <displayName>Person Or Oganization</displayName>
    <examples>The Tides Foundation</examples>
    <examples>Chemistry Department</examples>
    <examples>Paula Skinner</examples>
    <examples>CIA</examples>
    <examples>NeXT, Inc.</examples>
    <superKinds itemref="core:Item"/>
    <attributes itemref="core:displayName"/>
  </Kind>

</DomainSchema>

