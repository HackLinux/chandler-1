Only in SWIG-20Feb04-patched/Source/CParse: parser.c
Only in SWIG-20Feb04-patched/Source/CParse: parser.h
diff -u -r SWIG-20Feb04/Source/Modules/main.cxx SWIG-20Feb04-patched/Source/Modules/main.cxx
--- SWIG-20Feb04/Source/Modules/main.cxx	Mon Aug 16 15:50:50 2004
+++ SWIG-20Feb04-patched/Source/Modules/main.cxx	Mon Aug 16 16:40:19 2004
@@ -92,6 +92,7 @@
                                              \n\
                        where code 321(+) is added, and 401(no sign) and 402(-) \n\
                        are suppressed. See documentation for code meanings.\n\
+     -xmlout <file>  - Write an XML version of the parse tree to file after normal processing\n\
 \n";
 
 // Local variables
@@ -99,6 +100,7 @@
 static String  *lang_config = 0;
 static char    *cpp_extension = (char *) "cxx";
 static String  *outdir = 0;
+static String  *xmlout = 0;
 
 // -----------------------------------------------------------------------------
 // check_suffix(char *name)
@@ -216,6 +218,7 @@
   int     includecount = 0;
   int     dump_tags = 0;
   int     dump_tree = 0;
+  int     dump_xml = 0;
   int     browse = 0;
   int     dump_typedef = 0;
   int     dump_classes = 0;
@@ -484,6 +487,18 @@
 	  } else if (strcmp(argv[i],"-dump_tree") == 0) {
 	    dump_tree = 1;
 	    Swig_mark_arg(i);
+	  } else if (strcmp(argv[i],"-dump_xml") == 0) {
+	    dump_xml = 1;
+	    Swig_mark_arg(i);
+	  } else if (strcmp(argv[i],"-xmlout") == 0) {
+	    dump_xml = 1;
+	    Swig_mark_arg(i);
+	    if (argv[i+1]) {
+	      xmlout = NewString(argv[i+1]);	    
+	      Swig_mark_arg(i+1);
+	    } else {
+	      Swig_arg_error();
+	    }
 	  } else if (strcmp(argv[i],"-nocontract") == 0) {
 	    Swig_mark_arg(i);
 	    Swig_contract_mode_set(0);
@@ -735,6 +750,9 @@
     }
     if (dump_tree) {
       Swig_print_tree(top);
+    }
+    if (dump_xml) {
+      Swig_print_xml(top, xmlout);
     }
   }
   if (tm_debug) Swig_typemap_debug();
diff -u -r SWIG-20Feb04/Source/Modules/python.cxx SWIG-20Feb04-patched/Source/Modules/python.cxx
--- SWIG-20Feb04/Source/Modules/python.cxx	Mon Aug 16 15:53:13 2004
+++ SWIG-20Feb04-patched/Source/Modules/python.cxx	Mon Aug 16 16:37:19 2004
@@ -20,6 +20,7 @@
 static  String       *const_code = 0;
 static  String       *shadow_methods = 0;
 static  String       *module = 0;
+static  String       *package = 0;
 static  String       *mainmodule = 0;
 static  String       *interface = 0;
 static  String       *global_name = 0;
@@ -51,6 +52,16 @@
 static  int       have_repr;
 static  String   *real_classname;
 
+/* flags for the make_autodoc function */
+enum autodoc_t {
+  AUTODOC_CLASS,
+  AUTODOC_CTOR,
+  AUTODOC_DTOR,
+  AUTODOC_STATICFUNC,
+  AUTODOC_FUNC,
+  AUTODOC_METHOD
+};
+
 static const char *usage = (char *)"\
 Python Options (available with -python)\n\
      -ldflags        - Print runtime libraries to link with\n\
@@ -147,10 +158,11 @@
      * use %module(directors="1") modulename at the start of the 
      * interface file to enable director generation.
      */
+    String* mod_docstring = NULL;
     {
-      Node *module = Getattr(n, "module");
-      if (module) {
-        Node *options = Getattr(module, "options");
+      Node *mod = Getattr(n, "module");
+      if (mod) {
+        Node *options = Getattr(mod, "options");
         if (options) {
           if (Getattr(options, "directors")) {
             allow_directors();
@@ -158,6 +170,8 @@
           if (Getattr(options, "dirprot")) {
 	    allow_dirprot();
           }
+          mod_docstring = Getattr(options, "docstring");
+          package = Getattr(options, "package");
         }
       }
     }
@@ -259,6 +273,11 @@
                  "# This file is compatible with both classic and new-style classes.\n",
                  NIL);
       }
+
+      if (mod_docstring && Len(mod_docstring)) {
+        Printv(f_shadow, "\n\"\"\"\n", mod_docstring, "\n\"\"\"\n", NIL);
+        Delete(mod_docstring); mod_docstring = NULL;
+      }
       
       Printf(f_shadow,"\nimport %s\n\n", module);
 
@@ -383,7 +402,26 @@
     if (shadow) {
       String *modname = Getattr(n,"module");
       if (modname) {
-	Printf(f_shadow,"import %s\n", modname);
+        Printf(f_shadow,"import ");
+
+        // Find the module node for this imported module.  It should be the
+        // first child but search just in case.
+        Node* mod = firstChild(n);
+        while (mod && Strcmp(nodeType(mod), "module") != 0)
+          mod = nextSibling(mod);
+          
+        // Is the imported module in another package?  (IOW, does it use the
+        // %module(package="name") option and it's different than the package
+        // of this module.)
+        Node *options = Getattr(mod, "options");
+        if (options && Getattr(options, "package")) {
+          String* pkg = Getattr(options, "package");
+          if (!package || Strcmp(pkg, package) != 0)
+            Printf(f_shadow, "%s.", Getattr(options, "package"));
+        }
+
+        // finally, output the name of the imported module
+	Printf(f_shadow, "%s\n", modname);
       }
     }
     return Language::importDirective(n);
@@ -418,15 +456,23 @@
    * ------------------------------------------------------------ */
 
   void emitFunctionShadowHelper(Node *n, File *f_dest, String *name, int kw) {
-    if ( ! have_addtofunc(n) ) {
-      /* If there is no addtofunc directive then just assign from the extension module */
+    if ( !have_pythonprepend(n) && !have_pythonappend(n) && !have_docstring(n) ) {
+      /* If there is no pythonappend or docstring directive then just assign from the extension module */
       Printv(f_dest, "\n", name, " = ", module, ".", name, "\n", NIL);
     } else {
       /* Otherwise make a wrapper function to insert the code into */
       Printv(f_dest, "\ndef ", name, "(*args", (kw ? ", **kwargs" : ""), "):\n", NIL);
-      Printv(f_dest, tab4, "val = ", funcCallHelper(name, kw), "\n", NIL);
-      Printv(f_dest, tab4, addtofunc(n), "\n", NIL);
-      Printv(f_dest, tab4, "return val\n", NIL);
+      if ( have_docstring(n) )
+        Printv(f_dest, tab4, docstring(n, AUTODOC_FUNC, tab4), "\n", NIL);
+      if ( have_pythonprepend(n) )
+        Printv(f_dest, tab4, pythonprepend(n), "\n", NIL);
+      if ( have_pythonappend(n) ) {
+        Printv(f_dest, tab4, "val = ", funcCallHelper(name, kw), "\n", NIL);
+        Printv(f_dest, tab4, pythonappend(n), "\n", NIL);
+        Printv(f_dest, tab4, "return val\n", NIL);
+      } else {
+        Printv(f_dest, tab4, "return ", funcCallHelper(name, kw), "\n", NIL);
+      }        
     }
   }
 
@@ -442,22 +488,301 @@
 
 
   /* ------------------------------------------------------------
-   * have_addtofunc()
-   *    Check if there is a %addtofunc directive and it has text
+   * have_docstring()
+   *    Check if there is a docstring directive and it has text,
+   *    or there is an autodoc flag set
+   * ------------------------------------------------------------ */
+
+  bool have_docstring(Node *n) {
+    String* str = Getattr(n, "feature:docstring");
+    return (str != NULL && Len(str) > 0) ||
+        (Getattr(n,"feature:autodoc") && !Getattr(n, "feature:noautodoc"));
+  }
+  
+  /* ------------------------------------------------------------
+   * docstring()
+   *    Get the docstring text, stripping off {} if neccessary,
+   *    and enclose in triple double quotes.  If autodoc is also
+   *    set then it will build a combined docstring.
+   * ------------------------------------------------------------ */
+
+  String *docstring(Node *n, autodoc_t ad_type, const String* indent) {
+    String* str = Getattr(n, "feature:docstring");
+    bool have_ds = (str != NULL && Len(str) > 0);
+    bool have_auto = (Getattr(n,"feature:autodoc") && !Getattr(n, "feature:noautodoc"));
+    char* triple_double = "\"\"\"";
+    String* autodoc = NULL;
+    String* doc = NULL;
+
+    if ( have_ds ) {
+      char* t = Char(str);
+      if (*t == '{') {
+        Delitem(str ,0);
+        Delitem(str,DOH_END);
+      }
+    }
+
+    if ( have_auto ) {
+      autodoc = make_autodoc(n, ad_type);
+      have_auto = (autodoc != NULL && Len(autodoc) > 0);
+    }
+    
+    // If there is more than one line then make docstrings like this:
+    //
+    //      """
+    //      This is line1
+    //      And here is line2 followed by the rest of them
+    //      """
+    //
+    // otherwise, put it all on a single line
+    //
+    if ( have_auto && have_ds ) {       // Both autodoc and docstring are present
+      doc = NewString("");
+      Printv(doc, triple_double, "\n",
+                  pythoncode(autodoc, indent), "\n",
+                  pythoncode(str, indent), 
+                  indent, triple_double, NIL);
+    }
+    else if ( !have_auto && have_ds ) { // only docstring
+      if (Strchr(str, '\n') == NULL) {
+        doc = NewStringf("%s%s%s", triple_double, str, triple_double);
+      }
+      else {
+      doc = NewString("");
+      Printv(doc, triple_double, "\n",
+                  pythoncode(str, indent),
+                  indent, triple_double, NIL);
+      }
+    }
+    else if ( have_auto && !have_ds ) { // only autodoc
+      if (Strchr(autodoc, '\n') == NULL) {
+        doc = NewStringf("%s%s%s", triple_double, autodoc, triple_double);
+      }
+      else {
+      doc = NewString("");
+      Printv(doc, triple_double, "\n",
+                  pythoncode(autodoc, indent),
+                  indent, triple_double, NIL);
+      }
+    }
+    else
+      doc = NewString("");
+
+    // Save the generated strings in the parse tree in case they are used later
+    // by post processing tools
+    Setattr(n, "python:docstring", doc);
+    Setattr(n, "python:autodoc", autodoc);
+    return doc;
+  }
+
+
+  /* ------------------------------------------------------------
+   * make_autodoc()
+   *    Build a docstring for the node, using parameter and other
+   *    info in the parse tree.  If the value of the autodoc
+   *    attribute is "0" then do not include parameter types, if
+   *    it is "1" (the default) then do.  If it has some other
+   *    value then assume it is supplied by the extension writer
+   *    and use it directly.
    * ------------------------------------------------------------ */
 
-  bool have_addtofunc(Node *n) {
-    String* str = Getattr(n, "feature:addtofunc");
+  String* make_autodoc(Node *n, autodoc_t ad_type) {
+
+    if (ad_type == AUTODOC_CLASS)
+      return NULL;  // No function call to document in this case
+
+    // If the function is overloaded then this funciton is called
+    // for the last one.  Rewind to the first so the docstrings are
+    // in order.
+    while ( Getattr(n, "sym:previousSibling") )
+      n = Getattr(n, "sym:previousSibling");
+    
+    String* doc  = NewString("");
+    while (n) {
+      bool showTypes = false;
+      bool skipAuto = false;
+      
+      // check how should the parameters be rendered?
+      String* autodoc = Getattr(n, "feature:autodoc");
+      if (Strcmp(autodoc, "0") == 0)
+        showTypes = false;
+      else if (Strcmp(autodoc, "1") == 0)
+        showTypes = true;
+      else {
+        // if not "0" or "1" then autodoc is already the string that should be used
+        Printf(doc, "%s", autodoc);
+        skipAuto = true;
+      }
+
+      if (!skipAuto) {
+        String*   symname = Getattr(n, "sym:name");
+        SwigType* type    = Getattr(n, "type");
+      
+        if (type) {
+          if (Strcmp(type, "void") == 0)
+            type = NULL;
+          else {
+            SwigType* qt = SwigType_typedef_resolve_all(type);
+            if (SwigType_isenum(qt))
+              type = NewString("int");
+            else {
+              type = SwigType_base(type);
+              Node* lookup = Swig_symbol_clookup(type, 0);
+              if (lookup)
+                type = Getattr(lookup, "sym:name");
+            }
+          }     
+        }
+        
+        switch ( ad_type ) {
+        case AUTODOC_CTOR:
+          if ( Strcmp(class_name, symname) == 0) {
+            String* paramList = make_autodocParmList(n, showTypes);
+            if (Len(paramList))
+              Printf(doc, "__init__(self, %s) -> %s", paramList, class_name);
+            else
+              Printf(doc, "__init__(self) -> %s", class_name);
+          }              
+          else
+            Printf(doc, "%s(%s) -> %s", symname, make_autodocParmList(n, showTypes), class_name);
+          break;
+          
+        case AUTODOC_DTOR:
+          Printf(doc, "__del__(self)");
+          break;
+        
+        case AUTODOC_STATICFUNC:
+          Printf(doc, "%s(%s)", symname, make_autodocParmList(n, showTypes));
+          if (type) Printf(doc, " -> %s", type);
+          break;
+                      
+        case AUTODOC_FUNC:
+          Printf(doc, "%s(%s)", symname, make_autodocParmList(n, showTypes));
+          if (type) Printf(doc, " -> %s", type);
+          break;            
+
+        case AUTODOC_METHOD:
+          String* paramList = make_autodocParmList(n, showTypes);
+          if (Len(paramList))
+            Printf(doc, "%s(self, %s)", symname, paramList);
+          else
+            Printf(doc, "%s(self)", symname);
+          if (type) Printf(doc, " -> %s", type);
+          break;            
+        }
+      }
+      
+      // if it's overloaded then get the next decl and loop around again
+      n = Getattr(n, "sym:nextSibling");
+      if (n)
+        Printf(doc, "\n");
+    }
+          
+    return doc;
+  }
+
+
+  String* make_autodocParmList(Node* n, bool showTypes) {
+    String*   doc = NewString(""); 
+    ParmList* plist = Getattr(n,"parms");
+    Parm*     p;
+    Node*     lookup;
+    int       lines = 0;
+    const int maxwidth = 50;
+    
+
+    for (p = plist; p; p = nextSibling(p)) {
+      String*   name =  Getattr(p, "name");
+      String*   value = Getattr(p, "value");
+
+      if ( Len(doc) ) {
+        // add a comma to the previous one if any
+        Printf(doc, ", ");
+
+        // Do we need to wrap a long line?
+        if ((Len(doc) - lines*maxwidth) > maxwidth) {
+          Printf(doc, "\n%s", tab4);
+          lines += 1;
+        }
+      }
+        
+      // Do the param type too?
+      if (showTypes) {
+        SwigType* type =  SwigType_base(Getattr(p, "type"));
+        SwigType* qt = SwigType_typedef_resolve_all(type);
+        if (SwigType_isenum(qt))
+          type = NewString("int");
+        else {
+          lookup = Swig_symbol_clookup(type, 0);
+          if (lookup)
+            type = Getattr(lookup, "sym:name");
+        }
+        Printf(doc, "%s ", type);
+      }
+
+      if (name)
+        Printf(doc, "%s", name);
+      else
+        Printf(doc, "??");
+
+      if (value) {
+        if (Strcmp(value, "NULL") == 0)
+          value = NewString("None");
+        else {
+          lookup = Swig_symbol_clookup(value, 0);
+          if (lookup)
+            value = Getattr(lookup, "sym:name");
+        }
+        Printf(doc, "=%s", value);
+      }
+    }
+    
+    return doc;
+  }
+  
+  
+  /* ------------------------------------------------------------
+   * have_pythonprepend()
+   *    Check if there is a %pythonprepend directive and it has text
+   * ------------------------------------------------------------ */
+
+  bool have_pythonprepend(Node *n) {
+    String* str = Getattr(n, "feature:pythonprepend");
     return (str != NULL && Len(str) > 0);
   }
   
   /* ------------------------------------------------------------
-   * addtofunc()
-   *    Get the %addtofunc code, stripping off {} if neccessary
+   * pythonprepend()
+   *    Get the %pythonprepend code, stripping off {} if neccessary
    * ------------------------------------------------------------ */
 
-  String *addtofunc(Node *n) {
-    String* str = Getattr(n, "feature:addtofunc");
+  String *pythonprepend(Node *n) {
+    String* str = Getattr(n, "feature:pythonprepend");
+    char* t = Char(str);
+    if (*t == '{') {
+      Delitem(str ,0);
+      Delitem(str,DOH_END);
+    }
+    return str;
+  }
+    
+  /* ------------------------------------------------------------
+   * have_pythonappend()
+   *    Check if there is a %pythonappend directive and it has text
+   * ------------------------------------------------------------ */
+
+  bool have_pythonappend(Node *n) {
+    String* str = Getattr(n, "feature:pythonappend");
+    return (str != NULL && Len(str) > 0);
+  }
+  
+  /* ------------------------------------------------------------
+   * pythonappend()
+   *    Get the %pythonappend code, stripping off {} if neccessary
+   * ------------------------------------------------------------ */
+
+  String *pythonappend(Node *n) {
+    String* str = Getattr(n, "feature:pythonappend");
     char* t = Char(str);
     if (*t == '{') {
       Delitem(str ,0);
@@ -1658,7 +1983,16 @@
       if (mod) {
 	String *modname = Getattr(mod,"name");
 	if (Strcmp(modname,mainmodule) != 0) {
-	  importname = NewStringf("%s.%s", modname, Getattr(n,"sym:name"));
+          // check if the module has a package option
+          String* pkg = NULL;
+          Node *options = Getattr(mod, "options");
+          if (options && Getattr(options, "package")) 
+            pkg = Getattr(options, "package");
+
+          if (!package || Strcmp(pkg, package) != 0)
+            importname = NewStringf("%s.%s.%s", pkg, modname, Getattr(n,"sym:name"));
+          else
+            importname = NewStringf("%s.%s", modname, Getattr(n,"sym:name"));
 	} else {
 	  importname = NewString(Getattr(n,"sym:name"));
 	}
@@ -1732,7 +2066,9 @@
 	}
       }
       Printf(f_shadow,":\n");
-
+      if ( Getattr(n, "feature:docstring") ) // don't use have_docstring in this case because autodoc doesn't apply
+          Printv(f_shadow, tab4, docstring(n, AUTODOC_CLASS, tab4), "\n", NIL);
+      
       if (!modern) {
         Printv(f_shadow,tab4,"__swig_setmethods__ = {}\n",NIL);
         if (Len(base_class)) {
@@ -1867,14 +2203,22 @@
 	  Printv(f_shadow,pycode,"\n",NIL);
 	} else {
 
-          Printv(f_shadow, tab4, "def ", symname, "(*args", (allow_kwargs ? ", **kwargs" : ""), "): ", NIL);
-          if ( have_addtofunc(n) ) {
-            Printv(f_shadow, "\n", NIL);
-            Printv(f_shadow, tab8, "val = ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n", NIL);
-            Printv(f_shadow, tab8, addtofunc(n), "\n", NIL);
-            Printv(f_shadow, tab8, "return val\n", NIL);
+          Printv(f_shadow, tab4, "def ", symname, "(*args", (allow_kwargs ? ", **kwargs" : ""), "):", NIL);
+          if ( !have_pythonprepend(n) && !have_pythonappend(n) && !have_docstring(n)) {
+            Printv(f_shadow, " return ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n", NIL);
           } else {
-            Printv(f_shadow, "return ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n", NIL);
+            Printv(f_shadow, "\n", NIL);
+            if ( have_docstring(n) )
+              Printv(f_shadow, tab8, docstring(n, AUTODOC_METHOD, tab8), "\n", NIL);
+            if ( have_pythonprepend(n) )
+              Printv(f_shadow, tab8, pythonprepend(n), "\n", NIL);
+            if ( have_pythonappend(n) ) {
+              Printv(f_shadow, tab8, "val = ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n", NIL);
+              Printv(f_shadow, tab8, pythonappend(n), "\n", NIL);
+              Printv(f_shadow, tab8, "return val\n\n", NIL);
+            } else {
+              Printv(f_shadow, tab8, "return ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n\n", NIL);
+            }
           }
         }
 
@@ -1891,12 +2235,20 @@
     String *symname = Getattr(n,"sym:name");
     Language::staticmemberfunctionHandler(n);
     if (shadow) {
-      if ( !classic && have_addtofunc(n) ) {
+      if ( !classic && (have_pythonprepend(n) || have_pythonappend(n) || have_docstring(n)) ) {
         int kw = (check_kwargs(n) && !Getattr(n,"sym:overloaded")) ? 1 : 0;
         Printv(f_shadow, tab4, "def ", symname, "(*args", (kw ? ", **kwargs" : ""), "):\n", NIL);
-        Printv(f_shadow, tab8, "val = ", funcCallHelper(Swig_name_member(class_name, symname), kw), "\n", NIL);
-        Printv(f_shadow, tab8, addtofunc(n), "\n", NIL);
-        Printv(f_shadow, tab8, "return val\n", NIL);
+        if ( have_docstring(n) )
+          Printv(f_shadow, tab8, docstring(n, AUTODOC_STATICFUNC, tab8), "\n", NIL);
+        if ( have_pythonprepend(n) )
+          Printv(f_shadow, tab8, pythonprepend(n), "\n", NIL);
+        if ( have_pythonappend(n) ) {
+          Printv(f_shadow, tab8, "val = ", funcCallHelper(Swig_name_member(class_name, symname), kw), "\n", NIL);
+          Printv(f_shadow, tab8, pythonappend(n), "\n", NIL);
+          Printv(f_shadow, tab8, "return val\n\n", NIL);
+        } else {
+          Printv(f_shadow, tab8, "return ", funcCallHelper(Swig_name_member(class_name, symname), kw), "\n\n", NIL);
+        }
         Printv(f_shadow, tab4, modern ? "" : "if _newclass:",  symname,
                " = staticmethod(", symname, ")\n", NIL);
 
@@ -1983,6 +2335,10 @@
 
             Printv(f_shadow, tab4, "def __init__(self, *args",
                    (allow_kwargs ? ", **kwargs" : ""), "):\n", NIL);
+            if ( have_docstring(n) )
+              Printv(f_shadow, tab8, docstring(n, AUTODOC_CTOR, tab8), "\n", NIL);
+            if ( have_pythonprepend(n) )
+              Printv(f_shadow, tab8, pythonprepend(n), "\n", NIL);
             Printv(f_shadow, pass_self, NIL);
             if (!modern) {
               Printv(f_shadow, tab8, "_swig_setattr(self, ", rclassname, ", 'this', ", 
@@ -1997,8 +2353,8 @@
               Printv(f_shadow, tab8, "self.thisown = 1\n", NIL);
               Printv(f_shadow, tab8, "del newobj.thisown\n", NIL);
             }
-            if ( have_addtofunc(n) )
-              Printv(f_shadow, tab8, addtofunc(n), "\n", NIL);
+            if ( have_pythonappend(n) )
+              Printv(f_shadow, tab8, pythonappend(n), "\n\n", NIL);
   	    Delete(pass_self);
   	  }
 	  have_constructor = 1;
@@ -2016,11 +2372,15 @@
 
             Printv(f_shadow_stubs, "\ndef ", symname, "(*args",
                    (allow_kwargs ? ", **kwargs" : ""), "):\n", NIL);
+            if ( have_docstring(n) )
+              Printv(f_shadow_stubs, tab4, docstring(n, AUTODOC_CTOR, tab4), "\n", NIL);
+            if ( have_pythonprepend(n) )
+              Printv(f_shadow_stubs, tab4, pythonprepend(n), "\n", NIL);
             Printv(f_shadow_stubs, tab4, "val = ",
                    funcCallHelper(Swig_name_construct(symname), allow_kwargs), "\n", NIL);
 	    Printv(f_shadow_stubs, tab4, "val.thisown = 1\n", NIL);
-            if ( have_addtofunc(n) )
-              Printv(f_shadow_stubs, tab4, addtofunc(n), "\n", NIL);
+            if ( have_pythonappend(n) )
+              Printv(f_shadow_stubs, tab4, pythonappend(n), "\n", NIL);
             Printv(f_shadow_stubs, tab4, "return val\n", NIL);
   	  }
 	}
@@ -2049,11 +2409,16 @@
 	Printv(f_shadow,pycode,"\n", NIL);
       } else {
 	Printv(f_shadow, tab4, "def __del__(self, destroy=", module, ".", Swig_name_destroy(symname), "):\n", NIL);
-	if ( have_addtofunc(n) )
-	  Printv(f_shadow, tab8, addtofunc(n), "\n", NIL);
+        if ( have_docstring(n) )
+              Printv(f_shadow, tab8, docstring(n, AUTODOC_DTOR, tab8), "\n", NIL);
+	if ( have_pythonprepend(n) )
+	  Printv(f_shadow, tab8, pythonprepend(n), "\n", NIL);
 	Printv(f_shadow, tab8, "try:\n", NIL);
-	Printv(f_shadow, tab4, tab8, "if self.thisown: destroy(self)\n", NIL);
+	Printv(f_shadow, tab8, tab4, "if self.thisown: destroy(self)\n", NIL);
 	Printv(f_shadow, tab8, "except: pass\n", NIL);
+	if ( have_pythonappend(n) )
+	  Printv(f_shadow, tab8, pythonappend(n), "\n", NIL);
+        Printv(f_shadow, "\n", NIL);
       }
     }
     return SWIG_OK;
diff -u -r SWIG-20Feb04/Source/Modules/xml.cxx SWIG-20Feb04-patched/Source/Modules/xml.cxx
--- SWIG-20Feb04/Source/Modules/xml.cxx	Mon Aug 16 15:50:50 2004
+++ SWIG-20Feb04-patched/Source/Modules/xml.cxx	Mon Aug 16 16:44:37 2004
@@ -198,6 +198,7 @@
 					Replaceall( o, "<", "&lt;" );
 					Replaceall( o, "\"", "&quot;" );
 					Replaceall( o, "\\", "\\\\" );
+					Replaceall( o, "\n", "&#10;" );
 					Printf(out,"<attribute name=\"%s\" value=\"%s\" id=\"%ld\" addr=\"%x\" />\n", ck, o, ++id, o );
 					Delete(o);
 					Delete(ck);
@@ -319,9 +320,8 @@
 			print_indent(0);
 			Printf( out, "<%ssitem id=\"%ld\" addr=\"%x\" >\n", markup, ++id, n.item );
 			Xml_print_attributes( n.item );
-			Printf( out, "</%ssitem >\n", markup );
 			print_indent(0);
-			Printf( out, " />\n" );
+			Printf( out, "</%ssitem >\n", markup );
 			n = Next(n);
 		}
 		indent_level -= 4;
@@ -337,4 +337,34 @@
 }
 extern "C" Language * swig_xml( void ) {
         return new_swig_xml();
+}
+
+/* -----------------------------------------------------------------------------
+ * Swig_print_xml
+ *
+ * Dump an XML version of the parse tree.  This is different from using the -xml
+ * language module normally as it allows the real language module to process the
+ * tree first, possibly stuffing in new attributes, so the XML that is output ends
+ * up being a post-processing version of the tree.
+ * ----------------------------------------------------------------------------- */
+
+void 
+Swig_print_xml(DOH *obj, String* filename)
+{
+    XML xml;
+    xmllite = 1;
+
+    if (! filename) {
+        out = stdout;
+    }
+    else {
+        out = NewFile(filename, "w");
+        if (!out) {
+            Printf(stderr,"*** Can't open '%s'\n", filename);
+            SWIG_exit(EXIT_FAILURE);
+        }
+    }
+    
+    Printf( out, "<?xml version=\"1.0\" ?> \n" );
+    xml.Xml_print_tree(obj);
 }
diff -u -r SWIG-20Feb04/Source/Swig/swig.h SWIG-20Feb04-patched/Source/Swig/swig.h
--- SWIG-20Feb04/Source/Swig/swig.h	Mon Aug 16 15:55:19 2004
+++ SWIG-20Feb04-patched/Source/Swig/swig.h	Mon Aug 16 16:37:19 2004
@@ -359,6 +359,8 @@
 extern void Swig_print_tree(Node *obj);
 extern void Swig_print_node(Node *obj);
 
+extern void Swig_print_xml(Node *obj, String* filename);
+
 /* -- Wrapper function Object */
 
 typedef struct {

--- SWIG-20Feb04/Source/Modules/main.cxx	Fri Aug 20 15:45:52 2004
+++ SWIG-20Feb04-patched/Source/Modules/main.cxx	Fri Aug 20 15:44:39 2004
@@ -288,7 +288,7 @@
   // Check for SWIG_LIB environment variable
 
   if ((c = getenv("SWIG_LIB")) == (char *) 0) {
-#if defined(_WIN32)
+#if defined(_WIN32) && !defined(__GNUC__)
       char buf[MAX_PATH];
       char *p;
       if (GetModuleFileName(0, buf, MAX_PATH) == 0
